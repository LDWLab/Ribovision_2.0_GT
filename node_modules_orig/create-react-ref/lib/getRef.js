'use strict';

exports.__esModule = true;
exports.default = getRef;

var _forwardRef = require('./forwardRef');

var _RefForwarder = require('./RefForwarder');

var _RefForwarder2 = _interopRequireDefault(_RefForwarder);

var _warning = require('fbjs/lib/warning');

var _warning2 = _interopRequireDefault(_warning);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getRef(refObject) {
  if (!refObject) {
    return null;
  }

  var ref = refObject;

  if (typeof ref === 'function' && process.env.NODE_ENV !== 'production') {
    (0, _warning2.default)(ref.hasOwnProperty('current'), 'getRef: It looks like you may have passed `getRef` the ref callback as ' + 'an argument. `getRef` should be used with a ref object created by ' + '`createRef` or inside a ref callback.');
  }

  if (Object.keys(ref).length === 1) {
    if (ref.hasOwnProperty('current')) {
      ref = ref.current;
      // We probably don't have to support this route since it was only
      // in one version of React and it was an alpha release (16.3.0-alpha.1).
    } else if (ref.hasOwnProperty('value')) {
      ref = ref.value;
    }
  }

  // Get polyfilled forwardedRef, if it exists
  if (ref instanceof _RefForwarder2.default) {
    ref = ref.getRef();
  }

  return ref;
}
module.exports = exports['default'];