<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RNAlib-2.4.18: RNA Structure Notations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
  /* @license-end */
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="RNAlib-2.4.18"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RNAlib-2.4.18
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.html" method="get">
              <img id="MSearchSelect" src="search/mag.svg" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('rna_structure_notations.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">RNA Structure Notations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sec_structure_representations">Representations of Secondary Structures</a><ul><li class="level2"><a href="#dot-bracket-notation">Dot-Bracket Notation (a.k.a. Dot-Parenthesis Notation)</a></li>
<li class="level2"><a href="#wuss-notation">Washington University Secondary Structure (WUSS) notation</a></li>
<li class="level2"><a href="#shapes-notation">Abstract Shapes</a></li>
<li class="level2"><a href="#sec_structure_representations_tree">Tree Representations of Secondary Structures</a></li>
</ul>
</li>
<li class="level1"><a href="#structure_notations_examples">Examples for Structure Parsing and Conversion</a></li>
<li class="level1"><a href="#structure_notations_api">Structure Parsing and Conversion API</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="sec_structure_representations"></a>
Representations of Secondary Structures</h1>
<p>The standard representation of a secondary structure in our library is the <a class="el" href="rna_structure_notations.html#dot-bracket-notation">Dot-Bracket Notation (a.k.a. Dot-Parenthesis Notation)</a>, where matching brackets symbolize base pairs and unpaired bases are shown as dots. Based on that notation, more elaborate representations have been developed to include additional information, such as the loop context a nucleotide belongs to and to annotated pseudo-knots.</p>
<h2><a class="anchor" id="dot-bracket-notation"></a>
Dot-Bracket Notation (a.k.a. Dot-Parenthesis Notation)</h2>
<p>The Dot-Bracket notation as introduced already in the early times of the ViennaRNA Package denotes base pairs by matching pairs of parenthesis <code>()</code> and unpaired nucleotides by dots <code>.</code>.</p>
<p>As a simple example, consider a helix of size 4 enclosing a hairpin of size 4. In dot-bracket notation, this is annotated as</p>
<p><code>((((....))))</code></p>
<p><b>Extended Dot-Bracket Notation</b></p>
<p>A more generalized version of the original Dot-Bracket notation may use additional pairs of brackets, such as <code>&lt;&gt;</code>, <code>{}</code>, and <code>[]</code>, and matching pairs of uppercase/lowercase letters. This allows for anotating pseudo-knots, since different pairs of brackets are not required to be nested.</p>
<p>The follwing annotations of a simple structure with two crossing helices of size 4 are equivalent:</p>
<p><code>&lt;&lt;&lt;&lt;[[[[....&gt;&gt;&gt;&gt;]]]]</code><br  />
 <code>((((AAAA....))))aaaa</code><br  />
 <code>AAAA{{{{....aaaa}}}}</code> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__struct__utils__dot__bracket.html#ga55c4783060a1464f862f858d5599c9e1" title="Pack secondary secondary structure, 5:1 compression using base 3 encoding.">vrna_db_pack()</a>, <a class="el" href="group__struct__utils__dot__bracket.html#ga6490adff857d84ce06e6f379ae3a4512" title="Unpack secondary structure previously packed with vrna_db_pack()">vrna_db_unpack()</a>, <a class="el" href="group__struct__utils__dot__bracket.html#gafd1304f5a86e2e3f1425e725cde44fa2" title="Substitute pairs of brackets in a string with parenthesis.">vrna_db_flatten()</a>, <a class="el" href="group__struct__utils__dot__bracket.html#ga690425199c8b71545e7196e3af1436f8" title="Substitute pairs of brackets in a string with another type of pair characters.">vrna_db_flatten_to()</a>, <a class="el" href="group__struct__utils__dot__bracket.html#gaf9ecd0d7877fecdbb0292e24f40283d5" title="Convert a pair table into dot-parenthesis notation.">vrna_db_from_ptable()</a>, <a class="el" href="group__struct__utils__dot__bracket.html#ga6a51a36b9245d0bac868c5cd172b9611" title="Convert a list of base pairs into dot-bracket notation.">vrna_db_from_plist()</a>, <a class="el" href="group__struct__utils__dot__bracket.html#ga45360c09fb6d04d96e42dcccbb66015b" title="Convert a secondary structure in dot-bracket notation to a nucleotide annotation of loop contexts.">vrna_db_to_element_string()</a>, <a class="el" href="group__struct__utils__dot__bracket.html#ga97dbebaa3fc49524cf5afa338a6c52ee" title="Remove pseudo-knots from an input structure.">vrna_db_pk_remove()</a></dd></dl>
<h2><a class="anchor" id="wuss-notation"></a>
Washington University Secondary Structure (WUSS) notation</h2>
<p>The WUSS notation, as frequently used for consensus secondary structures in <a class="el" href="file_formats.html#msa-formats-stockholm">Stockholm 1.0 format</a>.</p>
<p>This notation allows for a fine-grained annotation of base pairs and unpaired nucleotides, including pseudo-knots. Below, you'll find a list of secondary structure elements and their corresponding WUSS annotation (See also the infernal user guide at <a href="http://eddylab.org/infernal/Userguide.pdf">http://eddylab.org/infernal/Userguide.pdf</a>) <ul>
<li><b>Base pairs</b><br  />
 Nested base pairs are annotated by matching pairs of the symbols <code>&lt;&gt;</code>, <code>()</code>, <code>{}</code>, and <code>[]</code>. Each of the matching pairs of parenthesis have their special meaning, however, when used as input in our programs, e.g. structure constraint, these details are usually ignored. Furthermore, base pairs that constitute as pseudo-knot are denoted by letters from the latin alphabet and are, if not denoted otherwise, ignored entirely in our programs.</li>
<li><p class="startli"><b>Hairpin loops</b><br  />
 Unpaired nucleotides that constitute the hairpin loop are indicated by underscores, <code>_</code>.</p>
<p class="startli">Example: <code>&lt;&lt;&lt;&lt;&lt;_____&gt;&gt;&gt;&gt;&gt;</code></p>
</li>
<li><p class="startli"><b>Bulges and interior loops</b><br  />
 Residues that constitute a bulge or interior loop are denoted by dashes, <code>-</code>.</p>
<p class="startli">Example: <code>(((--&lt;&lt;_____&gt;&gt;-)))</code></p>
</li>
<li><p class="startli"><b>Multibranch loops</b><br  />
 Unpaired nucleotides in multibranch loops are indicated by commas <code>,</code>.</p>
<p class="startli">Example: <code>(((,,&lt;&lt;_____&gt;&gt;,&lt;&lt;____&gt;&gt;)))</code></p>
</li>
<li><p class="startli"><b>External residues</b><br  />
 Single stranded nucleotides in the exterior loop, i.e. not enclosed by any other pair are denoted by colons, <code>:</code>.</p>
<p class="startli">Example: <code>&lt;&lt;&lt;____&gt;&gt;&gt;:::</code></p>
</li>
<li><b>Insertions</b><br  />
 In cases where an alignment represents the consensus with a known structure, insertions relative to the known structure are denoted by periods, <code>.</code>. Regions where local structural alignment was invoked, leaving regions of both target and query sequence unaligned, are indicated by tildes, <code>~</code>. <dl class="section note"><dt>Note</dt><dd>These symbols only appear in alignments of a known (query) structure annotation to a target sequence of unknown structure.</dd></dl>
</li>
<li><b>Pseudo-knots</b><br  />
 The WUSS notation allows for annotation of pseudo-knots using pairs of upper-case/lower-case letters. <dl class="section note"><dt>Note</dt><dd>Our programs and library functions usually ignore pseudo-knots entirely treating them as unpaired nucleotides, if not stated otherwise.</dd></dl>
Example: <code>&lt;&lt;&lt;_AAA___&gt;&gt;&gt;aaa</code> </li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__struct__utils__wuss.html#ga02ca70cffb2d864f7b2d95d92218bae0" title="Convert a WUSS annotation string to dot-bracket format.">vrna_db_from_WUSS()</a></dd></dl>
<h2><a class="anchor" id="shapes-notation"></a>
Abstract Shapes</h2>
<p>Abstract Shapes, introduced by Giegerich et al. in (2004) <a class="el" href="citelist.html#CITEREF_giegerich:2004">[10]</a>, collapse the secondary structure while retaining the nestedness of helices and hairpin loops.</p>
<p>The abstract shapes representation abstracts the structure from individual base pairs and their corresponding location in the sequence, while retaining the inherent nestedness of helices and hairpin loops.</p>
<p>Below is a description of what is included in the abstract shapes abstraction for each respective level together with an example structure: </p><pre class="fragment">CGUCUUAAACUCAUCACCGUGUGGAGCUGCGACCCUUCCCUAGAUUCGAAGACGAG
((((((...(((..(((...))))))...(((..((.....))..)))))))))..
</pre> <hr  />
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Shape Level   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Result    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">Most accurate - all loops and all unpaired   </td><td class="markdownTableBodyNone"><code>[_[_[]]_[_[]_]]_</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">Nesting pattern for all loop types and unpaired regions in external loop and multiloop   </td><td class="markdownTableBodyNone"><code>[[_[]][_[]_]]</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">Nesting pattern for all loop types but no unpaired regions   </td><td class="markdownTableBodyNone"><code>[[[]][[]]]</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">Helix nesting pattern in external loop and multiloop   </td><td class="markdownTableBodyNone"><code>[[][[]]]</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">Most abstract - helix nesting pattern and no unpaired regions   </td><td class="markdownTableBodyNone"><code>[[][]]</code>   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Our implementations also provide the special Shape Level 0, which does not collapse any structural features but simply convert base pairs and unpaired nucleotides into their corresponding set of symbols for abstract shapes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__struct__utils__abstract__shapes.html#gafca0add98ede22bf2c22608878c61b22" title="Convert a secondary structure in dot-bracket notation to its abstract shapes representation.">vrna_abstract_shapes()</a>, <a class="el" href="group__struct__utils__abstract__shapes.html#ga2fd59087e1c4e3d460e5823ba6d693b4" title="Convert a secondary structure to its abstract shapes representation.">vrna_abstract_shapes_pt()</a></dd></dl>
<h2><a class="anchor" id="sec_structure_representations_tree"></a>
Tree Representations of Secondary Structures</h2>
<p>Secondary structures can be readily represented as trees, where internal nodes represent base pairs, and leaves represent unpaired nucleotides. The dot-bracket structure string already is a tree represented by a string of parenthesis (base pairs) and dots for the leaf nodes (unpaired nucleotides).</p>
<p>Alternatively, one may find representations with two types of node labels, <code>P</code> for paired and <code>U</code> for unpaired; a dot is then replaced by <code>(U)</code>, and each closed bracket is assigned an additional identifier <code>P</code>. We call this the expanded notation. In <a class="el" href="citelist.html#CITEREF_fontana:1993b">[8]</a> a condensed representation of the secondary structure is proposed, the so-called homeomorphically irreducible tree (HIT) representation. Here a stack is represented as a single pair of matching brackets labeled <code>P</code> and weighted by the number of base pairs. Correspondingly, a contiguous strain of unpaired bases is shown as one pair of matching brackets labeled <code>U</code> and weighted by its length. Generally any string consisting of matching brackets and identifiers is equivalent to a plane tree with as many different types of nodes as there are identifiers.</p>
<p>Bruce Shapiro proposed a coarse grained representation <a class="el" href="citelist.html#CITEREF_shapiro:1988">[22]</a>, which, does not retain the full information of the secondary structure. He represents the different structure elements by single matching brackets and labels them as</p>
<ul>
<li><code>H</code> (hairpin loop),</li>
<li><code>I</code> (interior loop),</li>
<li><code>B</code> (bulge),</li>
<li><code>M</code> (multi-loop), and</li>
<li><code>S</code> (stack).</li>
</ul>
<p>We extend his alphabet by an extra letter for external elements <code>E</code>. Again these identifiers may be followed by a weight corresponding to the number of unpaired bases or base pairs in the structure element. All tree representations (except for the dot-bracket form) can be encapsulated into a virtual root (labeled <code>R</code>).</p>
<p>The following example illustrates the different linear tree representations used by the package:</p>
<p>Consider the secondary structure represented by the dot-bracket string (full tree) <code>.((..(((...)))..((..)))).</code> which is the most convenient condensed notation used by our programs and library functions.</p>
<p>Then, the following tree representations are equivalent:</p>
<ul>
<li>Expanded tree:<br  />
 <code>((U)(((U)(U)((((U)(U)(U)P)P)P)(U)(U)(((U)(U)P)P)P)P)(U)R)</code></li>
<li>HIT representation (Fontana et al. 1993 <a class="el" href="citelist.html#CITEREF_fontana:1993b">[8]</a>):<br  />
 <code>((U1)((U2)((U3)P3)(U2)((U2)P2)P2)(U1)R)</code></li>
<li>Coarse Grained <a class="el" href="structTree.html" title="Tree data structure.">Tree</a> Representation (Shapiro 1988 <a class="el" href="citelist.html#CITEREF_shapiro:1988">[22]</a>):<ul>
<li>Short (with root node <code>R</code>, without stem nodes <code>S</code>):<br  />
 <code>((H)((H)M)R)</code></li>
<li>Full (with root node <code>R</code>):<br  />
 <code>(((((H)S)((H)S)M)S)R)</code></li>
<li>Extended (with root node <code>R</code>, with external nodes <code>E</code>):<br  />
 <code>((((((H)S)((H)S)M)S)E)R)</code></li>
<li>Weighted (with root node <code>R</code>, with external nodes <code>E</code>):<br  />
 <code>((((((H3)S3)((H2)S2)M4)S2)E2)R)</code></li>
</ul>
</li>
</ul>
<p>The Expanded tree is rather clumsy and mostly included for the sake of completeness. The different versions of Coarse Grained <a class="el" href="structTree.html" title="Tree data structure.">Tree</a> Representations are variatios of Shapiro's linear tree notation.</p>
<p>For the output of aligned structures from string editing, different representations are needed, where we put the label on both sides. The above examples for tree representations would then look like:</p>
<pre class="fragment">*  a) (UU)(P(P(P(P(UU)(UU)(P(P(P(UU)(UU)(UU)P)P)P)(UU)(UU)(P(P(UU)(U...
*  b) (UU)(P2(P2(U2U2)(P2(U3U3)P3)(U2U2)(P2(U2U2)P2)P2)(UU)P2)(UU)
*  c) (B(M(HH)(HH)M)B)
*     (S(B(S(M(S(HH)S)(S(HH)S)M)S)B)S)
*     (E(S(B(S(M(S(HH)S)(S(HH)S)M)S)B)S)E)
*  d) (R(E2(S2(B1(S2(M4(S3(H3)S3)((H2)S2)M4)S2)B1)S2)E2)R)
*  </pre><p>Aligned structures additionally contain the gap character <code>_</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__struct__utils__tree.html#ga56551ab7da64933a7230d29430f40cfe" title="Convert a Dot-Bracket structure string into tree string representation.">vrna_db_to_tree_string()</a>, <a class="el" href="group__struct__utils__tree.html#gaa31da26a3f582ddc35a84ff1b9c0a2b0" title="Remove weights from a linear string tree representation of a secondary structure.">vrna_tree_string_unweight()</a>, <a class="el" href="group__struct__utils__tree.html#ga99d280319a7fd3f87e9f0d8c44520774" title="Convert a linear tree string representation of a secondary structure back to Dot-Bracket notation.">vrna_tree_string_to_db()</a></dd></dl>
<h1><a class="anchor" id="structure_notations_examples"></a>
Examples for Structure Parsing and Conversion</h1>
<h1><a class="anchor" id="structure_notations_api"></a>
Structure Parsing and Conversion API</h1>
<p>Several functions are provided for parsing structures and converting to different representations.</p>
<pre class="fragment">char  *expand_Full(const char *structure)
</pre><p> Convert the full structure from bracket notation to the expanded notation including root.</p>
<pre class="fragment">char *b2HIT (const char *structure)
</pre><p> Converts the full structure from bracket notation to the HIT notation including root.</p>
<pre class="fragment">char *b2C (const char *structure)
</pre><p> Converts the full structure from bracket notation to the a coarse grained notation using the 'H' 'B' 'I' 'M' and 'R' identifiers.</p>
<pre class="fragment">char *b2Shapiro (const char *structure)
</pre><p> Converts the full structure from bracket notation to the <em>weighted</em> coarse grained notation using the 'H' 'B' 'I' 'M' 'S' 'E' and 'R' identifiers.</p>
<pre class="fragment">char  *expand_Shapiro (const char *coarse);
</pre><p> Inserts missing 'S' identifiers in unweighted coarse grained structures as obtained from <a class="el" href="group__struct__utils__deprecated.html#ga9c80d92391f2833549a8b6dac92233f0" title="Converts the full structure from bracket notation to the a coarse grained notation using the &#39;H&#39; &#39;B&#39; ...">b2C()</a>.</p>
<pre class="fragment">char *add_root (const char *structure)
</pre><p> Adds a root to an un-rooted tree in any except bracket notation.</p>
<pre class="fragment">char  *unexpand_Full (const char *ffull)
</pre><p> Restores the bracket notation from an expanded full or HIT tree, that is any tree using only identifiers 'U' 'P' and 'R'.</p>
<pre class="fragment">char  *unweight (const char *wcoarse)
</pre><p> Strip weights from any weighted tree.</p>
<pre class="fragment">void   unexpand_aligned_F (char *align[2])
</pre><p> Converts two aligned structures in expanded notation.</p>
<pre class="fragment">void   parse_structure (const char *structure)
</pre><p> Collects a statistic of structure elements of the full structure in bracket notation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="RNAstruct_8h.html" title="Parsing and Coarse Graining of Structures.">RNAstruct.h</a> for prototypes and more detailed description </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Apr 23 2021 00:39:30 for RNAlib-2.4.18 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
