/*
  File autogenerated by gengetopt version 2.23
  generated with the following command:
  /usr/bin/gengetopt -i RNAalifold.ggo --file-name=RNAalifold_cmdl --include-getopt --default-optional --unamed-opts --func-name=RNAalifold_cmdline_parser --arg-struct-name=RNAalifold_args_info

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef FIX_UNUSED
#define FIX_UNUSED(X) (void) (X) /* avoid warnings for unused params */
#endif


#include "RNAalifold_cmdl.h"

const char *RNAalifold_args_info_purpose = "calculate secondary structures for a set of aligned RNAs";

const char *RNAalifold_args_info_usage = "Usage: RNAalifold [options] [<input0.aln>] [<input1.aln>]...";

const char *RNAalifold_args_info_versiontext = "";

const char *RNAalifold_args_info_description = "Read aligned RNA sequences from stdin or file.aln and calculate their minimum\nfree energy (mfe) structure, partition function (pf) and base pairing\nprobability matrix. Currently, input alignments have to be in CLUSTAL,\nStockholm, FASTA, or MAF format. The input format must be set manually in\ninteractive mode (default is Clustal), but will be determined automagically\nfrom the input file, if not expplicitly set. It returns the mfe structure in\nbracket notation, its energy, the free energy of the thermodynamic ensemble and\nthe frequency of the mfe structure in the ensemble to stdout.  It also produces\nPostscript files with plots of the resulting secondary structure graph\n(\"alirna.ps\") and a \"dot plot\" of the base pairing matrix (\"alidot.ps\").\nThe file \"alifold.out\" will contain a list of likely pairs sorted by\ncredibility, suitable for viewing  with \"AliDot.pl\". Be warned that output\nfile will overwrite any existing files of the same name.\n\n";

const char *RNAalifold_args_info_detailed_help[] = {
  "  -h, --help                    Print help and exit",
  "      --detailed-help           Print help, including all details and hidden\n                                  options, and exit",
  "      --full-help               Print help, including hidden options, and exit",
  "  -V, --version                 Print version and exit",
  "\nGeneral Options:",
  "  Command line options which alter the general behavior of this program\n\n",
  "  -v, --verbose                 Be verbose.\n\n                                    (default=off)",
  "  -q, --quiet                   Be quiet.\n                                    (default=off)",
  "  This option can be used to minimize the output of additional information and\n  non-severe warnings which otherwise might spam stdout/stderr.\n\n",
  "  -j, --jobs[=number]           Split batch input into jobs and start\n                                  processing in parallel using multiple\n                                  threads. A value of 0 indicates to use as\n                                  many parallel threads as computation cores\n                                  are available.\n                                    (default=`0')",
  "  Default processing of input data is performed in a serial fashion, i.e. one\n  alignment at a time. Using this switch, a user can instead start the\n  computation for many alignments in the input in parallel. RNAalifold will\n  create as many parallel computation slots as specified and assigns input\n  alignments of the input file(s) to the available slots. Note, that this\n  increases memory consumption since input alignments have to be kept in memory\n  until an empty compute slot is available and each running job requires its\n  own dynamic programming matrices.\n\n",
  "      --unordered               Do not try to keep output in order with input\n                                  while parallel processing is in place.\n                                    (default=off)",
  "  When parallel input processing (--jobs flag) is enabled, the order in which\n  input is processed depends on the host machines job scheduler. Therefore, any\n  output to stdout or files generated by this program will most likely not\n  follow the order of the corresponding input data set. The default of\n  RNAalifold is to use a specialized data structure to still keep the results\n  output in order with the input data. However, this comes with a trade-off in\n  terms of memory consumption, since all output must be kept in memory for as\n  long as no chunks of consecutive, ordered output are available. By setting\n  this flag, RNAalifold will not buffer individual results but print them as\n  soon as they have been computated.\n\n",
  "      --noconv                  Do not automatically substitute nucleotide\n                                  \"T\" with \"U\"\n\n                                    (default=off)",
  "      --color                   Produce a colored version of the consensus\n                                  structure plot \"alirna.ps\" (default b&w\n                                  only)\n\n                                    (default=off)",
  "      --aln                     Produce a colored and structure annotated\n                                  alignment in PostScript format in the file\n                                  \"aln.ps\" in the current directory.\n\n                                    (default=off)",
  "      --aln-EPS-cols=INT        Number of columns in colored EPS alignment\n                                  output.\n                                    (default=`60')",
  "  A value less than 1 indicates that the output should not be wrapped at all.\n\n",
  "      --aln-stk[=prefix]        Create a multi-Stockholm formatted output file.\n                                    (default=`RNAalifold_results')",
  "  The default file name used for the output is \"RNAalifold_results.stk\".\n  Users may change the filename to \"prefix.stk\" by specifying the prefix as\n  optional argument. The file will be create in the current directory if it\n  does not already exist. In case the file already exists, output will be\n  appended to it. Note: Any special characters in the filename will be replaced\n  by the filename delimiter, hence there is no way to pass an entire directory\n  path through this option yet. (See also the \"--filename-delim\" parameter)\n\n",
  "  -t, --layout-type=INT         Choose the layout algorithm. Simple radial\n                                  layout if 0, or naview if 1\n\n                                    (default=`1')",
  "      --noPS                    Do not produce postscript drawing of the mfe\n                                  structure.\n\n                                    (default=off)",
  "      --noDP                    Do not produce dot-plot postscript file\n                                  containing base pair or stack\n                                  probabilitities.\n                                    (default=off)",
  "  In combination with the -p option, this flag turns-off creation of individual\n  dot-plot files. Consequently, computed base pair probability output is\n  omitted but centroid and MEA structure prediction is still performed.\n\n",
  "  -f, --input-format=C|S|F|M    File format of the input multiple sequence\n                                  alignment (MSA).\n",
  "  If this parameter is set, the input is considered to be in a particular file\n  format. Otherwise, the program tries to determine the file format\n  automatically, if an input file was provided in the set of parameters. In\n  case the input MSA is provided in interactive mode, or from a terminal (TTY),\n  the programs default is to assume CLUSTALW format.\n  Currently, the following formats are available: ClustalW (C), Stockholm 1.0\n  (S), FASTA/Pearson (F), and MAF (M).\n\n",
  "  -n, --continuous-ids          Use continuous alignment ID numbering when no\n                                  alignment ID can be retrieved from input\n                                  data.\n                                    (default=off)",
  "  Due to its past, RNAalifold produces a specific set of output file names for\n  the first input alignment, \"alirna.ps\", \"alidot.ps\", etc. But for all\n  further alignments in the input, it usually adopts a naming scheme based on\n  IDs, which may be retrieved from the input alignment's meta-data, or\n  generated by a prefix followed by an increasing counter. Setting this flag\n  instructs RNAalifold to use the ID naming scheme also for the first\n  alignment.\n\n",
  "      --auto-id                 Automatically generate an ID for each\n                                  alignment.\n                                    (default=off)",
  "  The default mode of RNAalifold is to automatically determine an ID from the\n  input alignment if the input file format allows to do that. Alignment IDs\n  are, for instance, usually given in Stockholm 1.0 formatted input. If this\n  flag is active, RNAalifold ignores any IDs retrieved from the input and\n  automatically generates an ID for each alignment.\n\n",
  "      --id-prefix=prefix        Prefix for automatically generated IDs (as used\n                                  in output file names)\n\n                                    (default=`alignment')",
  "  If this parameter is set, each alignment will be prefixed with the provided\n  string. Hence, the output files will obey the following naming scheme:\n  \"prefix_xxxx_ss.ps\" (secondary structure plot), \"prefix_xxxx_dp.ps\"\n  (dot-plot), \"prefix_xxxx_aln.ps\" (annotated alignment), etc. where xxxx is\n  the alignment number beginning with the second alignment in the input. Use\n  this setting in conjunction with the --continuous-ids flag to assign IDs\n  beginning with the first input alignment.\n\n",
  "      --id-delim=delimiter      Change the delimiter between prefix and\n                                  increasing number for automatically generated\n                                  IDs (as used in output file names)\n\n                                    (default=`_')",
  "  This parameter can be used to change the default delimiter \"_\" between\n   the prefix string and the increasing number for automatically generated ID.\n\n",
  "      --id-digits=INT           Specify the number of digits of the counter in\n                                  automatically generated alignment IDs.\n                                    (default=`4')",
  "  When alignments IDs are automatically generated, they receive an increasing\n  number, starting with 1. This number will always be left-padded by leading\n  zeros, such that the number takes up a certain width. Using this parameter,\n  the width can be specified to the users need. We allow numbers in the range\n  [1:18].\n\n",
  "      --id-start=LONG           Specify the first number in automatically\n                                  generated alignment IDs.\n                                    (default=`1')",
  "  When alignment IDs are automatically generated, they receive an increasing\n  number, usually starting with 1. Using this parameter, the first number can\n  be specified to the users requirements. Note: negative numbers are not\n  allowed.\n  Note: Setting this parameter implies continuous alignment IDs, i.e. it\n  activates the --continuous-ids flag.\n\n",
  "      --filename-delim=delimiter\n                                Change the delimiting character that is used\n                                  for sanitized filenames\n\n                                    (default=`ID-delimiter')",
  "  This parameter can be used to change the delimiting character used while\n  sanitizing filenames, i.e. replacing invalid characters. Note, that the\n  default delimiter ALWAYS is the first character of the \"ID delimiter\" as\n  supplied through the --id-delim option. If the delimiter is a whitespace\n  character or empty, invalid characters will be simply removed rather than\n  substituted. Currently, we regard the following characters as illegal for use\n  in filenames: backslash '\', slash '/', question mark '?', percent sign '%',\n  asterisk '*', colon ':', pipe symbol '|', double quote '\"', triangular\n  brackets '<' and '>'.\n\n",
  "\nStructure Constraints:",
  "  Command line options to interact with the structure constraints feature of\n  this program\n\n",
  "      --maxBPspan=INT           Set the maximum base pair span\n\n                                    (default=`-1')",
  "  -C, --constraint[=<filename>] Calculate structures subject to constraints.\n                                  The constraining structure will be read from\n                                  'stdin', the alignment has to be given as a\n                                  file name on the command line.\n                                    (default=`')",
  "  The program reads first the sequence, then a string containing constraints on\n  the structure encoded with the symbols:\n\n  . (no constraint for this base)\n\n  | (the corresponding base has to be paired\n\n  x (the base is unpaired)\n\n  < (base i is paired with a base j>i)\n\n  > (base i is paired with a base j<i)\n\n  and matching brackets ( ) (base i pairs base j)\n\n  With the exception of \"|\", constraints will disallow all pairs conflicting\n  with the constraint. This is usually sufficient to enforce the constraint,\n  but occasionally a base may stay unpaired in spite of constraints. PF folding\n  ignores constraints of type \"|\".\n\n",
  "      --batch                   Use constraints for all alignment records.\n                                    (default=off)",
  "  Usually, constraints provided from input file are only applied to a single\n  sequence alignment. Therefore, RNAalifold will stop its computation and quit\n  after the first input alignment was processed. Using this switch, RNAalifold\n  processes all sequence alignments in the input and applies the same provided\n  constraints to each of them.\n\n",
  "      --enforceConstraint       Enforce base pairs given by round brackets ( )\n                                  in structure constraint\n\n                                    (default=off)",
  "      --SS_cons                 Use consensus structures from Stockholm file\n                                  (#=GF SS_cons) as constraint\n                                    (default=off)",
  "  Stockholm formatted alignment files have the possibility to store a secondary\n  structure string in one of if (\"#=GC\") column annotation meta tags. The\n  corresponding tag name is usually \"SS_cons\", a consensus secondary\n  structure. Activating this flag allows one to use this consensus secondary\n  structure from the input file as structure constraint. Currently, only the\n  following characters are interpreted:\n\n  ( ) [mathing parenthesis: column i pairs with column j]\n\n  < > [matching angular brackets: column i pairs with column j]\n\n  All other characters are not interpreted (yet).\n  Note: Activating this flag implies --constraint.\n\n",
  "      --shape=file1,file2       Use SHAPE reactivity data to guide structure\n                                  predictions\n",
  "  Multiple shapefiles for the individual sequences in the alignment may be\n  specified  as a comma separated list. An optional association of particular\n  shape files to a specific  sequence in the alignment can be expressed by\n  prepending the sequence number to the filename,  e.g.\n  \"5=seq5.shape,3=seq3.shape\" will assign the reactivity values from file\n  seq5.shape to  the fifth sequence in the alignment, and the values from file\n  seq3.shape to sequence 3. If  no assignment is specified, the reactivity\n  values are assigned to corresponding sequences in  the order they are given.\n\n",
  "      --shapeMethod=D[mX][bY]   Specify the method how to convert SHAPE\n                                  reactivity data to pseudo energy\n                                  contributions\n                                    (default=`D')",
  "  Currently, the only data conversion method available is that of to Deigan et\n  al 2009.  This method is the default and is recognized by a capital 'D' in\n  the provided parameter, i.e.:  --shapeMethod=\"D\" is the default setting.\n  The slope 'm' and the intercept 'b' can be set to a  non-default value if\n  necessary. Otherwise m=1.8 and b=-0.6 as stated in the paper mentionen\n  before.  To alter these parameters, e.g. m=1.9 and b=-0.7, use a  parameter\n  string like this: --shapeMethod=\"Dm1.9b-0.7\". You may also provide only one\n  of the two  parameters like: --shapeMethod=\"Dm1.9\" or\n  --shapeMethod=\"Db-0.7\".\n\n",
  "\nAlgorithms:",
  "  Select additional algorithms which should be included in the calculations.\n  The Minimum free energy (MFE) and a structure representative are calculated\n  in any case.\n\n",
  "  -p, --partfunc[=INT]          Calculate the partition function and base\n                                  pairing probability matrix in addition to the\n                                  mfe structure. Default is calculation of mfe\n                                  structure only.\n                                    (default=`1')",
  "  In addition to the MFE structure we print a coarse representation of the pair\n  probabilities in form of a pseudo bracket notation, followed by the ensemble\n  free energy, as well as the centroid structure derived from the pair\n  probabilities together with its free energy and distance to the ensemble.\n  Finally it prints the frequency of the mfe structure.\n\n  An additionally passed value to this option changes the behavior of partition\n  function calculation:\n  -p0 deactivates the calculation of the pair probabilities, saving about 50%\n  in runtime. This prints the ensemble free energy -kT ln(Z).\n\n",
  "      --MEA[=gamma]             Calculate an MEA (maximum expected accuracy)\n                                  structure, where the expected accuracy is\n                                  computed from the pair probabilities: each\n                                  base pair (i,j) gets a score 2*gamma*p_ij and\n                                  the score of an unpaired base is given by the\n                                  probability of not forming a pair.\n                                    (default=`1.')",
  "  The parameter gamma tunes the importance of correctly predicted pairs versus\n  unpaired bases. Thus, for small values of gamma the MEA structure will\n  contain only pairs with very high probability.\n  Using --MEA implies -p for computing the pair probabilities.\n\n",
  "      --mis                     Output \"most informative sequence\" instead of\n                                  simple consensus: For each column of the\n                                  alignment output the set of nucleotides with\n                                  frequency greater than average in IUPAC\n                                  notation.\n\n                                    (default=off)",
  "  -s, --stochBT=INT             Stochastic backtrack. Compute a certain number\n                                  of random structures with a probability\n                                  dependend on the partition function. See -p\n                                  option in RNAsubopt.\n\n",
  "      --stochBT_en=INT          same as \"-s\" but also print out the energies\n                                  and probabilities of the backtraced\n                                  structures.\n\n",
  "  -N, --nonRedundant            Enable non-redundant sampling strategy.\n\n                                    (default=off)",
  "  -S, --pfScale=scaling factor  In the calculation of the pf use scale*mfe as\n                                  an estimate for the ensemble free energy\n                                  (used to avoid overflows).\n",
  "  The default is 1.07, useful values are 1.0 to 1.2. Occasionally needed for\n  long sequences.\n  You can also recompile the program to use double precision (see the README\n  file).\n\n",
  "  -c, --circ                    Assume a circular (instead of linear) RNA\n                                  molecule.\n\n                                    (default=off)",
  "      --bppmThreshold=<value>   Set the threshold for base pair probabilities\n                                  included in the postscript output\n                                    (default=`1e-6')",
  "  By setting the threshold the base pair probabilities that are included in the\n  output can be varied. By default only those exceeding 1e-5 in probability\n  will be shown as squares in the dot plot. Changing the threshold to any other\n  value allows for increase or decrease of data.\n\n",
  "  -g, --gquad                   Incoorporate G-Quadruplex formation into the\n                                  structure prediction algorithm.\n\n                                    (default=off)",
  "      --sci                     Compute the structure conservation index (SCI)\n                                  for the MFE consensus structure of the\n                                  alignment\n\n                                    (default=off)",
  "\nModel Details:",
  "  -T, --temp=DOUBLE             Rescale energy parameters to a temperature of\n                                  temp C. Default is 37C.\n\n",
  "  -4, --noTetra                 Do not include special tabulated stabilizing\n                                  energies for tri-, tetra- and hexaloop\n                                  hairpins.\n\n                                    (default=off)",
  "  Mostly for testing.\n\n",
  "  -d, --dangles=INT             How to treat \"dangling end\" energies for\n                                  bases adjacent to helices in free ends and\n                                  multi-loops\n                                    (default=`2')",
  "  \n  With -d2 dangling energies will be added for the bases adjacent to a helix on\n  both sides\n   in any case.\n  The option -d0 ignores dangling ends altogether (mostly for debugging).\n\n",
  "      --noLP                    Produce structures without lonely pairs\n                                  (helices of length 1).\n                                    (default=off)",
  "  For partition function folding this only disallows pairs that can only occur\n  isolated. Other pairs may still occasionally occur as helices of length 1.\n\n",
  "      --noGU                    Do not allow GU pairs\n\n                                    (default=off)",
  "      --noClosingGU             Do not allow GU pairs at the end of helices\n\n                                    (default=off)",
  "      --cfactor=DOUBLE          Set the weight of the covariance term in the\n                                  energy function\n\n                                    (default=`1.0')",
  "      --nfactor=DOUBLE          Set the penalty for non-compatible sequences in\n                                  the covariance term of the energy function\n\n                                    (default=`1.0')",
  "  -E, --endgaps                 Score pairs with endgaps same as gap-gap pairs.\n\n                                    (default=off)",
  "  -R, --ribosum_file=ribosumfile\n                                use specified Ribosum Matrix instead of normal\n                                  energy model. Matrixes to use should be 6x6\n                                  matrices, the order of the terms is AU, CG,\n                                  GC, GU, UA, UG.\n\n",
  "  -r, --ribosum_scoring         use ribosum scoring matrix. The matrix is\n                                  chosen according to the minimal and maximal\n                                  pairwise identities of the sequences in the\n                                  file.\n\n                                    (default=off)",
  "      --old                     use old energy evaluation, treating gaps as\n                                  characters.\n\n                                    (default=off)",
  "  -P, --paramFile=paramfile     Read energy parameters from paramfile, instead\n                                  of using the default parameter set.\n",
  "  Different sets of energy parameters for RNA and DNA should accompany your\n  distribution.\n  See the RNAlib documentation for details on the file format. When passing the\n  placeholder file name \"DNA\", DNA parameters are loaded without the need to\n  actually specify any input file.\n\n",
  "      --nsp=STRING              Allow other pairs in addition to the usual\n                                  AU,GC,and GU pairs.\n",
  "  Its argument is a comma separated list of additionally allowed pairs. If the\n  first character is a \"-\" then AB will imply that AB and BA are allowed\n  pairs.\n  e.g. RNAfold -nsp -GA  will allow GA and AG pairs. Nonstandard pairs are\n  given 0 stacking energy.\n\n",
  "  -e, --energyModel=INT         Rarely used option to fold sequences from the\n                                  artificial ABCD... alphabet, where A pairs B,\n                                  C-D etc.  Use the energy parameters for GC\n                                  (-e 1) or AU (-e 2) pairs.\n\n",
  "      --betaScale=DOUBLE        Set the scaling of the Boltzmann factors\n                                    (default=`1.')",
  "  The argument provided with this option enables to scale the thermodynamic\n  temperature used in the Boltzmann factors independently from the temperature\n  used to scale the individual energy contributions of the loop types. The\n  Boltzmann factors then become exp(-dG/(kTn*betaScale)) where k is the\n  Boltzmann constant, dG the free energy contribution of the state, T the\n  absolute temperature and n the number of sequences.\n\n",
  "Caveats:\n\nSequences are not weighted. If possible, do not mix very similar and dissimilar\nsequences. Duplicate sequences, for example, can distort the prediction.\n\n\nIf in doubt our program is right, nature is at fault.\nComments should be sent to rna@tbi.univie.ac.at.\n\n",
    0
};
static void
init_full_help_array(void)
{
  RNAalifold_args_info_full_help[0] = RNAalifold_args_info_detailed_help[0];
  RNAalifold_args_info_full_help[1] = RNAalifold_args_info_detailed_help[1];
  RNAalifold_args_info_full_help[2] = RNAalifold_args_info_detailed_help[2];
  RNAalifold_args_info_full_help[3] = RNAalifold_args_info_detailed_help[3];
  RNAalifold_args_info_full_help[4] = RNAalifold_args_info_detailed_help[4];
  RNAalifold_args_info_full_help[5] = RNAalifold_args_info_detailed_help[5];
  RNAalifold_args_info_full_help[6] = RNAalifold_args_info_detailed_help[6];
  RNAalifold_args_info_full_help[7] = RNAalifold_args_info_detailed_help[7];
  RNAalifold_args_info_full_help[8] = RNAalifold_args_info_detailed_help[9];
  RNAalifold_args_info_full_help[9] = RNAalifold_args_info_detailed_help[11];
  RNAalifold_args_info_full_help[10] = RNAalifold_args_info_detailed_help[13];
  RNAalifold_args_info_full_help[11] = RNAalifold_args_info_detailed_help[14];
  RNAalifold_args_info_full_help[12] = RNAalifold_args_info_detailed_help[15];
  RNAalifold_args_info_full_help[13] = RNAalifold_args_info_detailed_help[16];
  RNAalifold_args_info_full_help[14] = RNAalifold_args_info_detailed_help[18];
  RNAalifold_args_info_full_help[15] = RNAalifold_args_info_detailed_help[20];
  RNAalifold_args_info_full_help[16] = RNAalifold_args_info_detailed_help[21];
  RNAalifold_args_info_full_help[17] = RNAalifold_args_info_detailed_help[22];
  RNAalifold_args_info_full_help[18] = RNAalifold_args_info_detailed_help[24];
  RNAalifold_args_info_full_help[19] = RNAalifold_args_info_detailed_help[26];
  RNAalifold_args_info_full_help[20] = RNAalifold_args_info_detailed_help[28];
  RNAalifold_args_info_full_help[21] = RNAalifold_args_info_detailed_help[30];
  RNAalifold_args_info_full_help[22] = RNAalifold_args_info_detailed_help[32];
  RNAalifold_args_info_full_help[23] = RNAalifold_args_info_detailed_help[34];
  RNAalifold_args_info_full_help[24] = RNAalifold_args_info_detailed_help[36];
  RNAalifold_args_info_full_help[25] = RNAalifold_args_info_detailed_help[38];
  RNAalifold_args_info_full_help[26] = RNAalifold_args_info_detailed_help[40];
  RNAalifold_args_info_full_help[27] = RNAalifold_args_info_detailed_help[41];
  RNAalifold_args_info_full_help[28] = RNAalifold_args_info_detailed_help[42];
  RNAalifold_args_info_full_help[29] = RNAalifold_args_info_detailed_help[43];
  RNAalifold_args_info_full_help[30] = RNAalifold_args_info_detailed_help[45];
  RNAalifold_args_info_full_help[31] = RNAalifold_args_info_detailed_help[47];
  RNAalifold_args_info_full_help[32] = RNAalifold_args_info_detailed_help[48];
  RNAalifold_args_info_full_help[33] = RNAalifold_args_info_detailed_help[50];
  RNAalifold_args_info_full_help[34] = RNAalifold_args_info_detailed_help[52];
  RNAalifold_args_info_full_help[35] = RNAalifold_args_info_detailed_help[54];
  RNAalifold_args_info_full_help[36] = RNAalifold_args_info_detailed_help[55];
  RNAalifold_args_info_full_help[37] = RNAalifold_args_info_detailed_help[56];
  RNAalifold_args_info_full_help[38] = RNAalifold_args_info_detailed_help[58];
  RNAalifold_args_info_full_help[39] = RNAalifold_args_info_detailed_help[60];
  RNAalifold_args_info_full_help[40] = RNAalifold_args_info_detailed_help[61];
  RNAalifold_args_info_full_help[41] = RNAalifold_args_info_detailed_help[62];
  RNAalifold_args_info_full_help[42] = RNAalifold_args_info_detailed_help[63];
  RNAalifold_args_info_full_help[43] = RNAalifold_args_info_detailed_help[64];
  RNAalifold_args_info_full_help[44] = RNAalifold_args_info_detailed_help[66];
  RNAalifold_args_info_full_help[45] = RNAalifold_args_info_detailed_help[67];
  RNAalifold_args_info_full_help[46] = RNAalifold_args_info_detailed_help[69];
  RNAalifold_args_info_full_help[47] = RNAalifold_args_info_detailed_help[70];
  RNAalifold_args_info_full_help[48] = RNAalifold_args_info_detailed_help[71];
  RNAalifold_args_info_full_help[49] = RNAalifold_args_info_detailed_help[72];
  RNAalifold_args_info_full_help[50] = RNAalifold_args_info_detailed_help[73];
  RNAalifold_args_info_full_help[51] = RNAalifold_args_info_detailed_help[75];
  RNAalifold_args_info_full_help[52] = RNAalifold_args_info_detailed_help[77];
  RNAalifold_args_info_full_help[53] = RNAalifold_args_info_detailed_help[79];
  RNAalifold_args_info_full_help[54] = RNAalifold_args_info_detailed_help[80];
  RNAalifold_args_info_full_help[55] = RNAalifold_args_info_detailed_help[81];
  RNAalifold_args_info_full_help[56] = RNAalifold_args_info_detailed_help[82];
  RNAalifold_args_info_full_help[57] = RNAalifold_args_info_detailed_help[83];
  RNAalifold_args_info_full_help[58] = RNAalifold_args_info_detailed_help[84];
  RNAalifold_args_info_full_help[59] = RNAalifold_args_info_detailed_help[85];
  RNAalifold_args_info_full_help[60] = RNAalifold_args_info_detailed_help[86];
  RNAalifold_args_info_full_help[61] = RNAalifold_args_info_detailed_help[87];
  RNAalifold_args_info_full_help[62] = RNAalifold_args_info_detailed_help[89];
  RNAalifold_args_info_full_help[63] = RNAalifold_args_info_detailed_help[91];
  RNAalifold_args_info_full_help[64] = RNAalifold_args_info_detailed_help[92];
  RNAalifold_args_info_full_help[65] = RNAalifold_args_info_detailed_help[94];
  RNAalifold_args_info_full_help[66] = 0; 
  
}

const char *RNAalifold_args_info_full_help[67];

static void
init_help_array(void)
{
  RNAalifold_args_info_help[0] = RNAalifold_args_info_detailed_help[0];
  RNAalifold_args_info_help[1] = RNAalifold_args_info_detailed_help[1];
  RNAalifold_args_info_help[2] = RNAalifold_args_info_detailed_help[2];
  RNAalifold_args_info_help[3] = RNAalifold_args_info_detailed_help[3];
  RNAalifold_args_info_help[4] = RNAalifold_args_info_detailed_help[4];
  RNAalifold_args_info_help[5] = RNAalifold_args_info_detailed_help[5];
  RNAalifold_args_info_help[6] = RNAalifold_args_info_detailed_help[6];
  RNAalifold_args_info_help[7] = RNAalifold_args_info_detailed_help[7];
  RNAalifold_args_info_help[8] = RNAalifold_args_info_detailed_help[9];
  RNAalifold_args_info_help[9] = RNAalifold_args_info_detailed_help[13];
  RNAalifold_args_info_help[10] = RNAalifold_args_info_detailed_help[14];
  RNAalifold_args_info_help[11] = RNAalifold_args_info_detailed_help[15];
  RNAalifold_args_info_help[12] = RNAalifold_args_info_detailed_help[18];
  RNAalifold_args_info_help[13] = RNAalifold_args_info_detailed_help[21];
  RNAalifold_args_info_help[14] = RNAalifold_args_info_detailed_help[22];
  RNAalifold_args_info_help[15] = RNAalifold_args_info_detailed_help[24];
  RNAalifold_args_info_help[16] = RNAalifold_args_info_detailed_help[26];
  RNAalifold_args_info_help[17] = RNAalifold_args_info_detailed_help[28];
  RNAalifold_args_info_help[18] = RNAalifold_args_info_detailed_help[30];
  RNAalifold_args_info_help[19] = RNAalifold_args_info_detailed_help[40];
  RNAalifold_args_info_help[20] = RNAalifold_args_info_detailed_help[41];
  RNAalifold_args_info_help[21] = RNAalifold_args_info_detailed_help[42];
  RNAalifold_args_info_help[22] = RNAalifold_args_info_detailed_help[43];
  RNAalifold_args_info_help[23] = RNAalifold_args_info_detailed_help[45];
  RNAalifold_args_info_help[24] = RNAalifold_args_info_detailed_help[47];
  RNAalifold_args_info_help[25] = RNAalifold_args_info_detailed_help[48];
  RNAalifold_args_info_help[26] = RNAalifold_args_info_detailed_help[50];
  RNAalifold_args_info_help[27] = RNAalifold_args_info_detailed_help[52];
  RNAalifold_args_info_help[28] = RNAalifold_args_info_detailed_help[54];
  RNAalifold_args_info_help[29] = RNAalifold_args_info_detailed_help[55];
  RNAalifold_args_info_help[30] = RNAalifold_args_info_detailed_help[56];
  RNAalifold_args_info_help[31] = RNAalifold_args_info_detailed_help[58];
  RNAalifold_args_info_help[32] = RNAalifold_args_info_detailed_help[60];
  RNAalifold_args_info_help[33] = RNAalifold_args_info_detailed_help[61];
  RNAalifold_args_info_help[34] = RNAalifold_args_info_detailed_help[62];
  RNAalifold_args_info_help[35] = RNAalifold_args_info_detailed_help[63];
  RNAalifold_args_info_help[36] = RNAalifold_args_info_detailed_help[66];
  RNAalifold_args_info_help[37] = RNAalifold_args_info_detailed_help[69];
  RNAalifold_args_info_help[38] = RNAalifold_args_info_detailed_help[70];
  RNAalifold_args_info_help[39] = RNAalifold_args_info_detailed_help[71];
  RNAalifold_args_info_help[40] = RNAalifold_args_info_detailed_help[72];
  RNAalifold_args_info_help[41] = RNAalifold_args_info_detailed_help[73];
  RNAalifold_args_info_help[42] = RNAalifold_args_info_detailed_help[75];
  RNAalifold_args_info_help[43] = RNAalifold_args_info_detailed_help[77];
  RNAalifold_args_info_help[44] = RNAalifold_args_info_detailed_help[79];
  RNAalifold_args_info_help[45] = RNAalifold_args_info_detailed_help[80];
  RNAalifold_args_info_help[46] = RNAalifold_args_info_detailed_help[81];
  RNAalifold_args_info_help[47] = RNAalifold_args_info_detailed_help[82];
  RNAalifold_args_info_help[48] = RNAalifold_args_info_detailed_help[83];
  RNAalifold_args_info_help[49] = RNAalifold_args_info_detailed_help[84];
  RNAalifold_args_info_help[50] = RNAalifold_args_info_detailed_help[85];
  RNAalifold_args_info_help[51] = RNAalifold_args_info_detailed_help[86];
  RNAalifold_args_info_help[52] = RNAalifold_args_info_detailed_help[87];
  RNAalifold_args_info_help[53] = RNAalifold_args_info_detailed_help[94];
  RNAalifold_args_info_help[54] = 0; 
  
}

const char *RNAalifold_args_info_help[55];

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_INT
  , ARG_LONG
  , ARG_FLOAT
  , ARG_DOUBLE
} RNAalifold_cmdline_parser_arg_type;

static
void clear_given (struct RNAalifold_args_info *args_info);
static
void clear_args (struct RNAalifold_args_info *args_info);

static int
RNAalifold_cmdline_parser_internal (int argc, char **argv, struct RNAalifold_args_info *args_info,
                        struct RNAalifold_cmdline_parser_params *params, const char *additional_error);

static int
RNAalifold_cmdline_parser_required2 (struct RNAalifold_args_info *args_info, const char *prog_name, const char *additional_error);

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct RNAalifold_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->detailed_help_given = 0 ;
  args_info->full_help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->verbose_given = 0 ;
  args_info->quiet_given = 0 ;
  args_info->jobs_given = 0 ;
  args_info->unordered_given = 0 ;
  args_info->noconv_given = 0 ;
  args_info->color_given = 0 ;
  args_info->aln_given = 0 ;
  args_info->aln_EPS_cols_given = 0 ;
  args_info->aln_stk_given = 0 ;
  args_info->layout_type_given = 0 ;
  args_info->noPS_given = 0 ;
  args_info->noDP_given = 0 ;
  args_info->input_format_given = 0 ;
  args_info->continuous_ids_given = 0 ;
  args_info->auto_id_given = 0 ;
  args_info->id_prefix_given = 0 ;
  args_info->id_delim_given = 0 ;
  args_info->id_digits_given = 0 ;
  args_info->id_start_given = 0 ;
  args_info->filename_delim_given = 0 ;
  args_info->maxBPspan_given = 0 ;
  args_info->constraint_given = 0 ;
  args_info->batch_given = 0 ;
  args_info->enforceConstraint_given = 0 ;
  args_info->SS_cons_given = 0 ;
  args_info->shape_given = 0 ;
  args_info->shapeMethod_given = 0 ;
  args_info->partfunc_given = 0 ;
  args_info->MEA_given = 0 ;
  args_info->mis_given = 0 ;
  args_info->stochBT_given = 0 ;
  args_info->stochBT_en_given = 0 ;
  args_info->nonRedundant_given = 0 ;
  args_info->pfScale_given = 0 ;
  args_info->circ_given = 0 ;
  args_info->bppmThreshold_given = 0 ;
  args_info->gquad_given = 0 ;
  args_info->sci_given = 0 ;
  args_info->temp_given = 0 ;
  args_info->noTetra_given = 0 ;
  args_info->dangles_given = 0 ;
  args_info->noLP_given = 0 ;
  args_info->noGU_given = 0 ;
  args_info->noClosingGU_given = 0 ;
  args_info->cfactor_given = 0 ;
  args_info->nfactor_given = 0 ;
  args_info->endgaps_given = 0 ;
  args_info->ribosum_file_given = 0 ;
  args_info->ribosum_scoring_given = 0 ;
  args_info->old_given = 0 ;
  args_info->paramFile_given = 0 ;
  args_info->nsp_given = 0 ;
  args_info->energyModel_given = 0 ;
  args_info->betaScale_given = 0 ;
}

static
void clear_args (struct RNAalifold_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->verbose_flag = 0;
  args_info->quiet_flag = 0;
  args_info->jobs_arg = 0;
  args_info->jobs_orig = NULL;
  args_info->unordered_flag = 0;
  args_info->noconv_flag = 0;
  args_info->color_flag = 0;
  args_info->aln_flag = 0;
  args_info->aln_EPS_cols_arg = 60;
  args_info->aln_EPS_cols_orig = NULL;
  args_info->aln_stk_arg = gengetopt_strdup ("RNAalifold_results");
  args_info->aln_stk_orig = NULL;
  args_info->layout_type_arg = 1;
  args_info->layout_type_orig = NULL;
  args_info->noPS_flag = 0;
  args_info->noDP_flag = 0;
  args_info->input_format_arg = NULL;
  args_info->input_format_orig = NULL;
  args_info->continuous_ids_flag = 0;
  args_info->auto_id_flag = 0;
  args_info->id_prefix_arg = gengetopt_strdup ("alignment");
  args_info->id_prefix_orig = NULL;
  args_info->id_delim_arg = gengetopt_strdup ("_");
  args_info->id_delim_orig = NULL;
  args_info->id_digits_arg = 4;
  args_info->id_digits_orig = NULL;
  args_info->id_start_arg = 1;
  args_info->id_start_orig = NULL;
  args_info->filename_delim_arg = gengetopt_strdup ("ID-delimiter");
  args_info->filename_delim_orig = NULL;
  args_info->maxBPspan_arg = -1;
  args_info->maxBPspan_orig = NULL;
  args_info->constraint_arg = gengetopt_strdup ("");
  args_info->constraint_orig = NULL;
  args_info->batch_flag = 0;
  args_info->enforceConstraint_flag = 0;
  args_info->SS_cons_flag = 0;
  args_info->shape_arg = NULL;
  args_info->shape_orig = NULL;
  args_info->shapeMethod_arg = gengetopt_strdup ("D");
  args_info->shapeMethod_orig = NULL;
  args_info->partfunc_arg = 1;
  args_info->partfunc_orig = NULL;
  args_info->MEA_arg = 1.;
  args_info->MEA_orig = NULL;
  args_info->mis_flag = 0;
  args_info->stochBT_orig = NULL;
  args_info->stochBT_en_orig = NULL;
  args_info->nonRedundant_flag = 0;
  args_info->pfScale_orig = NULL;
  args_info->circ_flag = 0;
  args_info->bppmThreshold_arg = 1e-6;
  args_info->bppmThreshold_orig = NULL;
  args_info->gquad_flag = 0;
  args_info->sci_flag = 0;
  args_info->temp_orig = NULL;
  args_info->noTetra_flag = 0;
  args_info->dangles_arg = 2;
  args_info->dangles_orig = NULL;
  args_info->noLP_flag = 0;
  args_info->noGU_flag = 0;
  args_info->noClosingGU_flag = 0;
  args_info->cfactor_arg = 1.0;
  args_info->cfactor_orig = NULL;
  args_info->nfactor_arg = 1.0;
  args_info->nfactor_orig = NULL;
  args_info->endgaps_flag = 0;
  args_info->ribosum_file_arg = NULL;
  args_info->ribosum_file_orig = NULL;
  args_info->ribosum_scoring_flag = 0;
  args_info->old_flag = 0;
  args_info->paramFile_arg = NULL;
  args_info->paramFile_orig = NULL;
  args_info->nsp_arg = NULL;
  args_info->nsp_orig = NULL;
  args_info->energyModel_orig = NULL;
  args_info->betaScale_arg = 1.;
  args_info->betaScale_orig = NULL;
  
}

static
void init_args_info(struct RNAalifold_args_info *args_info)
{
  init_full_help_array(); 
  init_help_array(); 
  args_info->help_help = RNAalifold_args_info_detailed_help[0] ;
  args_info->detailed_help_help = RNAalifold_args_info_detailed_help[1] ;
  args_info->full_help_help = RNAalifold_args_info_detailed_help[2] ;
  args_info->version_help = RNAalifold_args_info_detailed_help[3] ;
  args_info->verbose_help = RNAalifold_args_info_detailed_help[6] ;
  args_info->quiet_help = RNAalifold_args_info_detailed_help[7] ;
  args_info->jobs_help = RNAalifold_args_info_detailed_help[9] ;
  args_info->unordered_help = RNAalifold_args_info_detailed_help[11] ;
  args_info->noconv_help = RNAalifold_args_info_detailed_help[13] ;
  args_info->color_help = RNAalifold_args_info_detailed_help[14] ;
  args_info->aln_help = RNAalifold_args_info_detailed_help[15] ;
  args_info->aln_EPS_cols_help = RNAalifold_args_info_detailed_help[16] ;
  args_info->aln_stk_help = RNAalifold_args_info_detailed_help[18] ;
  args_info->layout_type_help = RNAalifold_args_info_detailed_help[20] ;
  args_info->noPS_help = RNAalifold_args_info_detailed_help[21] ;
  args_info->noDP_help = RNAalifold_args_info_detailed_help[22] ;
  args_info->input_format_help = RNAalifold_args_info_detailed_help[24] ;
  args_info->continuous_ids_help = RNAalifold_args_info_detailed_help[26] ;
  args_info->auto_id_help = RNAalifold_args_info_detailed_help[28] ;
  args_info->id_prefix_help = RNAalifold_args_info_detailed_help[30] ;
  args_info->id_delim_help = RNAalifold_args_info_detailed_help[32] ;
  args_info->id_digits_help = RNAalifold_args_info_detailed_help[34] ;
  args_info->id_start_help = RNAalifold_args_info_detailed_help[36] ;
  args_info->filename_delim_help = RNAalifold_args_info_detailed_help[38] ;
  args_info->maxBPspan_help = RNAalifold_args_info_detailed_help[42] ;
  args_info->constraint_help = RNAalifold_args_info_detailed_help[43] ;
  args_info->batch_help = RNAalifold_args_info_detailed_help[45] ;
  args_info->enforceConstraint_help = RNAalifold_args_info_detailed_help[47] ;
  args_info->SS_cons_help = RNAalifold_args_info_detailed_help[48] ;
  args_info->shape_help = RNAalifold_args_info_detailed_help[50] ;
  args_info->shape_min = 1;
  args_info->shape_max = 0;
  args_info->shapeMethod_help = RNAalifold_args_info_detailed_help[52] ;
  args_info->partfunc_help = RNAalifold_args_info_detailed_help[56] ;
  args_info->MEA_help = RNAalifold_args_info_detailed_help[58] ;
  args_info->mis_help = RNAalifold_args_info_detailed_help[60] ;
  args_info->stochBT_help = RNAalifold_args_info_detailed_help[61] ;
  args_info->stochBT_en_help = RNAalifold_args_info_detailed_help[62] ;
  args_info->nonRedundant_help = RNAalifold_args_info_detailed_help[63] ;
  args_info->pfScale_help = RNAalifold_args_info_detailed_help[64] ;
  args_info->circ_help = RNAalifold_args_info_detailed_help[66] ;
  args_info->bppmThreshold_help = RNAalifold_args_info_detailed_help[67] ;
  args_info->gquad_help = RNAalifold_args_info_detailed_help[69] ;
  args_info->sci_help = RNAalifold_args_info_detailed_help[70] ;
  args_info->temp_help = RNAalifold_args_info_detailed_help[72] ;
  args_info->noTetra_help = RNAalifold_args_info_detailed_help[73] ;
  args_info->dangles_help = RNAalifold_args_info_detailed_help[75] ;
  args_info->noLP_help = RNAalifold_args_info_detailed_help[77] ;
  args_info->noGU_help = RNAalifold_args_info_detailed_help[79] ;
  args_info->noClosingGU_help = RNAalifold_args_info_detailed_help[80] ;
  args_info->cfactor_help = RNAalifold_args_info_detailed_help[81] ;
  args_info->nfactor_help = RNAalifold_args_info_detailed_help[82] ;
  args_info->endgaps_help = RNAalifold_args_info_detailed_help[83] ;
  args_info->ribosum_file_help = RNAalifold_args_info_detailed_help[84] ;
  args_info->ribosum_scoring_help = RNAalifold_args_info_detailed_help[85] ;
  args_info->old_help = RNAalifold_args_info_detailed_help[86] ;
  args_info->paramFile_help = RNAalifold_args_info_detailed_help[87] ;
  args_info->nsp_help = RNAalifold_args_info_detailed_help[89] ;
  args_info->energyModel_help = RNAalifold_args_info_detailed_help[91] ;
  args_info->betaScale_help = RNAalifold_args_info_detailed_help[92] ;
  
}

void
RNAalifold_cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(RNAALIFOLD_CMDLINE_PARSER_PACKAGE_NAME) ? RNAALIFOLD_CMDLINE_PARSER_PACKAGE_NAME : RNAALIFOLD_CMDLINE_PARSER_PACKAGE),
     RNAALIFOLD_CMDLINE_PARSER_VERSION);

  if (strlen(RNAalifold_args_info_versiontext) > 0)
    printf("\n%s\n", RNAalifold_args_info_versiontext);
}

static void print_help_common(void)
{
	size_t len_purpose = strlen(RNAalifold_args_info_purpose);
	size_t len_usage = strlen(RNAalifold_args_info_usage);

	if (len_usage > 0) {
		printf("%s\n", RNAalifold_args_info_usage);
	}
	if (len_purpose > 0) {
		printf("%s\n", RNAalifold_args_info_purpose);
	}

	if (len_usage || len_purpose) {
		printf("\n");
	}

	if (strlen(RNAalifold_args_info_description) > 0) {
		printf("%s\n\n", RNAalifold_args_info_description);
	}
}

void
RNAalifold_cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (RNAalifold_args_info_help[i])
    printf("%s\n", RNAalifold_args_info_help[i++]);
}

void
RNAalifold_cmdline_parser_print_full_help (void)
{
  int i = 0;
  print_help_common();
  while (RNAalifold_args_info_full_help[i])
    printf("%s\n", RNAalifold_args_info_full_help[i++]);
}

void
RNAalifold_cmdline_parser_print_detailed_help (void)
{
  int i = 0;
  print_help_common();
  while (RNAalifold_args_info_detailed_help[i])
    printf("%s\n", RNAalifold_args_info_detailed_help[i++]);
}

void
RNAalifold_cmdline_parser_init (struct RNAalifold_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = 0;
  args_info->inputs_num = 0;
}

void
RNAalifold_cmdline_parser_params_init(struct RNAalifold_cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct RNAalifold_cmdline_parser_params *
RNAalifold_cmdline_parser_params_create(void)
{
  struct RNAalifold_cmdline_parser_params *params = 
    (struct RNAalifold_cmdline_parser_params *)malloc(sizeof(struct RNAalifold_cmdline_parser_params));
  RNAalifold_cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}

/** @brief generic value variable */
union generic_value {
    int int_arg;
    long long_arg;
    float float_arg;
    double double_arg;
    char *string_arg;
    const char *default_string_arg;
};

/** @brief holds temporary values for multiple options */
struct generic_list
{
  union generic_value arg;
  char *orig;
  struct generic_list *next;
};

/**
 * @brief add a node at the head of the list 
 */
static void add_node(struct generic_list **list) {
  struct generic_list *new_node = (struct generic_list *) malloc (sizeof (struct generic_list));
  new_node->next = *list;
  *list = new_node;
  new_node->arg.string_arg = 0;
  new_node->orig = 0;
}


static void
free_multiple_string_field(unsigned int len, char ***arg, char ***orig)
{
  unsigned int i;
  if (*arg) {
    for (i = 0; i < len; ++i)
      {
        free_string_field(&((*arg)[i]));
        free_string_field(&((*orig)[i]));
      }
    free_string_field(&((*arg)[0])); /* free default string */

    free (*arg);
    *arg = 0;
    free (*orig);
    *orig = 0;
  }
}

static void
RNAalifold_cmdline_parser_release (struct RNAalifold_args_info *args_info)
{
  unsigned int i;
  free_string_field (&(args_info->jobs_orig));
  free_string_field (&(args_info->aln_EPS_cols_orig));
  free_string_field (&(args_info->aln_stk_arg));
  free_string_field (&(args_info->aln_stk_orig));
  free_string_field (&(args_info->layout_type_orig));
  free_string_field (&(args_info->input_format_arg));
  free_string_field (&(args_info->input_format_orig));
  free_string_field (&(args_info->id_prefix_arg));
  free_string_field (&(args_info->id_prefix_orig));
  free_string_field (&(args_info->id_delim_arg));
  free_string_field (&(args_info->id_delim_orig));
  free_string_field (&(args_info->id_digits_orig));
  free_string_field (&(args_info->id_start_orig));
  free_string_field (&(args_info->filename_delim_arg));
  free_string_field (&(args_info->filename_delim_orig));
  free_string_field (&(args_info->maxBPspan_orig));
  free_string_field (&(args_info->constraint_arg));
  free_string_field (&(args_info->constraint_orig));
  free_multiple_string_field (args_info->shape_given, &(args_info->shape_arg), &(args_info->shape_orig));
  free_string_field (&(args_info->shapeMethod_arg));
  free_string_field (&(args_info->shapeMethod_orig));
  free_string_field (&(args_info->partfunc_orig));
  free_string_field (&(args_info->MEA_orig));
  free_string_field (&(args_info->stochBT_orig));
  free_string_field (&(args_info->stochBT_en_orig));
  free_string_field (&(args_info->pfScale_orig));
  free_string_field (&(args_info->bppmThreshold_orig));
  free_string_field (&(args_info->temp_orig));
  free_string_field (&(args_info->dangles_orig));
  free_string_field (&(args_info->cfactor_orig));
  free_string_field (&(args_info->nfactor_orig));
  free_string_field (&(args_info->ribosum_file_arg));
  free_string_field (&(args_info->ribosum_file_orig));
  free_string_field (&(args_info->paramFile_arg));
  free_string_field (&(args_info->paramFile_orig));
  free_string_field (&(args_info->nsp_arg));
  free_string_field (&(args_info->nsp_orig));
  free_string_field (&(args_info->energyModel_orig));
  free_string_field (&(args_info->betaScale_orig));
  
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);

  if (args_info->inputs_num)
    free (args_info->inputs);

  clear_given (args_info);
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  FIX_UNUSED (values);
  if (arg) {
    fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}

static void
write_multiple_into_file(FILE *outfile, int len, const char *opt, char **arg, const char *values[])
{
  int i;
  
  for (i = 0; i < len; ++i)
    write_into_file(outfile, opt, (arg ? arg[i] : 0), values);
}

int
RNAalifold_cmdline_parser_dump(FILE *outfile, struct RNAalifold_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", RNAALIFOLD_CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->detailed_help_given)
    write_into_file(outfile, "detailed-help", 0, 0 );
  if (args_info->full_help_given)
    write_into_file(outfile, "full-help", 0, 0 );
  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->verbose_given)
    write_into_file(outfile, "verbose", 0, 0 );
  if (args_info->quiet_given)
    write_into_file(outfile, "quiet", 0, 0 );
  if (args_info->jobs_given)
    write_into_file(outfile, "jobs", args_info->jobs_orig, 0);
  if (args_info->unordered_given)
    write_into_file(outfile, "unordered", 0, 0 );
  if (args_info->noconv_given)
    write_into_file(outfile, "noconv", 0, 0 );
  if (args_info->color_given)
    write_into_file(outfile, "color", 0, 0 );
  if (args_info->aln_given)
    write_into_file(outfile, "aln", 0, 0 );
  if (args_info->aln_EPS_cols_given)
    write_into_file(outfile, "aln-EPS-cols", args_info->aln_EPS_cols_orig, 0);
  if (args_info->aln_stk_given)
    write_into_file(outfile, "aln-stk", args_info->aln_stk_orig, 0);
  if (args_info->layout_type_given)
    write_into_file(outfile, "layout-type", args_info->layout_type_orig, 0);
  if (args_info->noPS_given)
    write_into_file(outfile, "noPS", 0, 0 );
  if (args_info->noDP_given)
    write_into_file(outfile, "noDP", 0, 0 );
  if (args_info->input_format_given)
    write_into_file(outfile, "input-format", args_info->input_format_orig, 0);
  if (args_info->continuous_ids_given)
    write_into_file(outfile, "continuous-ids", 0, 0 );
  if (args_info->auto_id_given)
    write_into_file(outfile, "auto-id", 0, 0 );
  if (args_info->id_prefix_given)
    write_into_file(outfile, "id-prefix", args_info->id_prefix_orig, 0);
  if (args_info->id_delim_given)
    write_into_file(outfile, "id-delim", args_info->id_delim_orig, 0);
  if (args_info->id_digits_given)
    write_into_file(outfile, "id-digits", args_info->id_digits_orig, 0);
  if (args_info->id_start_given)
    write_into_file(outfile, "id-start", args_info->id_start_orig, 0);
  if (args_info->filename_delim_given)
    write_into_file(outfile, "filename-delim", args_info->filename_delim_orig, 0);
  if (args_info->maxBPspan_given)
    write_into_file(outfile, "maxBPspan", args_info->maxBPspan_orig, 0);
  if (args_info->constraint_given)
    write_into_file(outfile, "constraint", args_info->constraint_orig, 0);
  if (args_info->batch_given)
    write_into_file(outfile, "batch", 0, 0 );
  if (args_info->enforceConstraint_given)
    write_into_file(outfile, "enforceConstraint", 0, 0 );
  if (args_info->SS_cons_given)
    write_into_file(outfile, "SS_cons", 0, 0 );
  write_multiple_into_file(outfile, args_info->shape_given, "shape", args_info->shape_orig, 0);
  if (args_info->shapeMethod_given)
    write_into_file(outfile, "shapeMethod", args_info->shapeMethod_orig, 0);
  if (args_info->partfunc_given)
    write_into_file(outfile, "partfunc", args_info->partfunc_orig, 0);
  if (args_info->MEA_given)
    write_into_file(outfile, "MEA", args_info->MEA_orig, 0);
  if (args_info->mis_given)
    write_into_file(outfile, "mis", 0, 0 );
  if (args_info->stochBT_given)
    write_into_file(outfile, "stochBT", args_info->stochBT_orig, 0);
  if (args_info->stochBT_en_given)
    write_into_file(outfile, "stochBT_en", args_info->stochBT_en_orig, 0);
  if (args_info->nonRedundant_given)
    write_into_file(outfile, "nonRedundant", 0, 0 );
  if (args_info->pfScale_given)
    write_into_file(outfile, "pfScale", args_info->pfScale_orig, 0);
  if (args_info->circ_given)
    write_into_file(outfile, "circ", 0, 0 );
  if (args_info->bppmThreshold_given)
    write_into_file(outfile, "bppmThreshold", args_info->bppmThreshold_orig, 0);
  if (args_info->gquad_given)
    write_into_file(outfile, "gquad", 0, 0 );
  if (args_info->sci_given)
    write_into_file(outfile, "sci", 0, 0 );
  if (args_info->temp_given)
    write_into_file(outfile, "temp", args_info->temp_orig, 0);
  if (args_info->noTetra_given)
    write_into_file(outfile, "noTetra", 0, 0 );
  if (args_info->dangles_given)
    write_into_file(outfile, "dangles", args_info->dangles_orig, 0);
  if (args_info->noLP_given)
    write_into_file(outfile, "noLP", 0, 0 );
  if (args_info->noGU_given)
    write_into_file(outfile, "noGU", 0, 0 );
  if (args_info->noClosingGU_given)
    write_into_file(outfile, "noClosingGU", 0, 0 );
  if (args_info->cfactor_given)
    write_into_file(outfile, "cfactor", args_info->cfactor_orig, 0);
  if (args_info->nfactor_given)
    write_into_file(outfile, "nfactor", args_info->nfactor_orig, 0);
  if (args_info->endgaps_given)
    write_into_file(outfile, "endgaps", 0, 0 );
  if (args_info->ribosum_file_given)
    write_into_file(outfile, "ribosum_file", args_info->ribosum_file_orig, 0);
  if (args_info->ribosum_scoring_given)
    write_into_file(outfile, "ribosum_scoring", 0, 0 );
  if (args_info->old_given)
    write_into_file(outfile, "old", 0, 0 );
  if (args_info->paramFile_given)
    write_into_file(outfile, "paramFile", args_info->paramFile_orig, 0);
  if (args_info->nsp_given)
    write_into_file(outfile, "nsp", args_info->nsp_orig, 0);
  if (args_info->energyModel_given)
    write_into_file(outfile, "energyModel", args_info->energyModel_orig, 0);
  if (args_info->betaScale_given)
    write_into_file(outfile, "betaScale", args_info->betaScale_orig, 0);
  

  i = EXIT_SUCCESS;
  return i;
}

int
RNAalifold_cmdline_parser_file_save(const char *filename, struct RNAalifold_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", RNAALIFOLD_CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = RNAalifold_cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
RNAalifold_cmdline_parser_free (struct RNAalifold_args_info *args_info)
{
  RNAalifold_cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

static char *
get_multiple_arg_token(const char *arg)
{
  const char *tok;
  char *ret;
  size_t len, num_of_escape, i, j;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');
  num_of_escape = 0;

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
          ++num_of_escape;
        }
      else
        break;
    }

  if (tok)
    len = (size_t)(tok - arg + 1);
  else
    len = strlen (arg) + 1;

  len -= num_of_escape;

  ret = (char *) malloc (len);

  i = 0;
  j = 0;
  while (arg[i] && (j < len-1))
    {
      if (arg[i] == '\\' && 
	  arg[ i + 1 ] && 
	  arg[ i + 1 ] == ',')
        ++i;

      ret[j++] = arg[i++];
    }

  ret[len-1] = '\0';

  return ret;
}

static const char *
get_multiple_arg_token_next(const char *arg)
{
  const char *tok;

  if (!arg)
    return 0;

  tok = strchr (arg, ',');

  /* make sure it is not escaped */
  while (tok)
    {
      if (*(tok-1) == '\\')
        {
          /* find the next one */
          tok = strchr (tok+1, ',');
        }
      else
        break;
    }

  if (! tok || strlen(tok) == 1)
    return 0;

  return tok+1;
}

static int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc);

int
check_multiple_option_occurrences(const char *prog_name, unsigned int option_given, unsigned int min, unsigned int max, const char *option_desc)
{
  int error_occurred = 0;

  if (option_given && (min > 0 || max > 0))
    {
      if (min > 0 && max > 0)
        {
          if (min == max)
            {
              /* specific occurrences */
              if (option_given != (unsigned int) min)
                {
                  fprintf (stderr, "%s: %s option occurrences must be %d\n",
                    prog_name, option_desc, min);
                  error_occurred = 1;
                }
            }
          else if (option_given < (unsigned int) min
                || option_given > (unsigned int) max)
            {
              /* range occurrences */
              fprintf (stderr, "%s: %s option occurrences must be between %d and %d\n",
                prog_name, option_desc, min, max);
              error_occurred = 1;
            }
        }
      else if (min > 0)
        {
          /* at least check */
          if (option_given < min)
            {
              fprintf (stderr, "%s: %s option occurrences must be at least %d\n",
                prog_name, option_desc, min);
              error_occurred = 1;
            }
        }
      else if (max > 0)
        {
          /* at most check */
          if (option_given > max)
            {
              fprintf (stderr, "%s: %s option occurrences must be at most %d\n",
                prog_name, option_desc, max);
              error_occurred = 1;
            }
        }
    }
    
  return error_occurred;
}
int
RNAalifold_cmdline_parser (int argc, char **argv, struct RNAalifold_args_info *args_info)
{
  return RNAalifold_cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
RNAalifold_cmdline_parser_ext (int argc, char **argv, struct RNAalifold_args_info *args_info,
                   struct RNAalifold_cmdline_parser_params *params)
{
  int result;
  result = RNAalifold_cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      RNAalifold_cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
RNAalifold_cmdline_parser2 (int argc, char **argv, struct RNAalifold_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct RNAalifold_cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = RNAalifold_cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      RNAalifold_cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
RNAalifold_cmdline_parser_required (struct RNAalifold_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (RNAalifold_cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      RNAalifold_cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
RNAalifold_cmdline_parser_required2 (struct RNAalifold_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  if (check_multiple_option_occurrences(prog_name, args_info->shape_given, args_info->shape_min, args_info->shape_max, "'--shape'"))
     error_occurred = 1;
  
  
  /* checks for dependences among options */
  if (args_info->unordered_given && ! args_info->jobs_given)
    {
      fprintf (stderr, "%s: '--unordered' option depends on option 'jobs'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->noDP_given && ! args_info->partfunc_given)
    {
      fprintf (stderr, "%s: '--noDP' option depends on option 'partfunc'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->batch_given && ! args_info->constraint_given)
    {
      fprintf (stderr, "%s: '--batch' option depends on option 'constraint'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->enforceConstraint_given && ! args_info->constraint_given)
    {
      fprintf (stderr, "%s: '--enforceConstraint' option depends on option 'constraint'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->shapeMethod_given && ! args_info->shape_given)
    {
      fprintf (stderr, "%s: '--shapeMethod' option depends on option 'shape'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->betaScale_given && ! args_info->partfunc_given)
    {
      fprintf (stderr, "%s: '--betaScale' option depends on option 'partfunc'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }

  return error_occurred;
}

/*
 * Extracted from the glibc source tree, version 2.3.6
 *
 * Licensed under the GPL as per the whole glibc source tree.
 *
 * This file was modified so that getopt_long can be called
 * many times without risking previous memory to be spoiled.
 *
 * Modified by Andre Noll and Lorenzo Bettini for use in
 * GNU gengetopt generated files.
 *
 */

/* 
 * we must include anything we need since this file is not thought to be
 * inserted in a file already using getopt.h
 *
 * Lorenzo
 */

struct option
{
  const char *name;
  /* has_arg can't be an enum because some compilers complain about
     type mismatches in all the code that assumes it is an int.  */
  int has_arg;
  int *flag;
  int val;
};

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.
*/
/*
   If the field `flag' is not NULL, it points to a variable that is set
   to the value given in the field `val' when the option is found, but
   left unchanged if the option is not found.

   To have a long-named option do something other than set an `int' to
   a compiled-in constant, such as set a value from `custom_optarg', set the
   option's `flag' field to zero and its `val' field to a nonzero
   value (the equivalent single-letter option character, if there is
   one).  For long options that have a zero `flag' field, `getopt'
   returns the contents of the `val' field.  */

/* Names for the values of the `has_arg' field of `struct option'.  */
#ifndef no_argument
#define no_argument		0
#endif

#ifndef required_argument
#define required_argument	1
#endif

#ifndef optional_argument
#define optional_argument	2
#endif

struct custom_getopt_data {
	/*
	 * These have exactly the same meaning as the corresponding global variables,
	 * except that they are used for the reentrant versions of getopt.
	 */
	int custom_optind;
	int custom_opterr;
	int custom_optopt;
	char *custom_optarg;

	/* True if the internal members have been initialized.  */
	int initialized;

	/*
	 * The next char to be scanned in the option-element in which the last option
	 * character we returned was found.  This allows us to pick up the scan where
	 * we left off.  If this is zero, or a null string, it means resume the scan by
	 * advancing to the next ARGV-element.
	 */
	char *nextchar;

	/*
	 * Describe the part of ARGV that contains non-options that have been skipped.
	 * `first_nonopt' is the index in ARGV of the first of them; `last_nonopt' is
	 * the index after the last of them.
	 */
	int first_nonopt;
	int last_nonopt;
};

/*
 * the variables optarg, optind, opterr and optopt are renamed with
 * the custom_ prefix so that they don't interfere with getopt ones.
 *
 * Moreover they're static so they are visible only from within the
 * file where this very file will be included.
 */

/*
 * For communication from `custom_getopt' to the caller.  When `custom_getopt' finds an
 * option that takes an argument, the argument value is returned here.
 */
static char *custom_optarg;

/*
 * Index in ARGV of the next element to be scanned.  This is used for
 * communication to and from the caller and for communication between
 * successive calls to `custom_getopt'.
 *
 * On entry to `custom_getopt', 1 means this is the first call; initialize.
 *
 * When `custom_getopt' returns -1, this is the index of the first of the non-option
 * elements that the caller should itself scan.
 *
 * Otherwise, `custom_optind' communicates from one call to the next how much of ARGV
 * has been scanned so far.
 *
 * 1003.2 says this must be 1 before any call.
 */
static int custom_optind = 1;

/*
 * Callers store zero here to inhibit the error message for unrecognized
 * options.
 */
static int custom_opterr = 1;

/*
 * Set to an option character which was unrecognized.  This must be initialized
 * on some systems to avoid linking in the system's own getopt implementation.
 */
static int custom_optopt = '?';

/*
 * Exchange two adjacent subsequences of ARGV.  One subsequence is elements
 * [first_nonopt,last_nonopt) which contains all the non-options that have been
 * skipped so far.  The other is elements [last_nonopt,custom_optind), which contains
 * all the options processed since those non-options were skipped.
 * `first_nonopt' and `last_nonopt' are relocated so that they describe the new
 * indices of the non-options in ARGV after they are moved.
 */
static void exchange(char **argv, struct custom_getopt_data *d)
{
	int bottom = d->first_nonopt;
	int middle = d->last_nonopt;
	int top = d->custom_optind;
	char *tem;

	/*
	 * Exchange the shorter segment with the far end of the longer segment.
	 * That puts the shorter segment into the right place.  It leaves the
	 * longer segment in the right place overall, but it consists of two
	 * parts that need to be swapped next.
	 */
	while (top > middle && middle > bottom) {
		if (top - middle > middle - bottom) {
			/* Bottom segment is the short one.  */
			int len = middle - bottom;
			int i;

			/* Swap it with the top part of the top segment.  */
			for (i = 0; i < len; i++) {
				tem = argv[bottom + i];
				argv[bottom + i] =
					argv[top - (middle - bottom) + i];
				argv[top - (middle - bottom) + i] = tem;
			}
			/* Exclude the moved bottom segment from further swapping.  */
			top -= len;
		} else {
			/* Top segment is the short one.  */
			int len = top - middle;
			int i;

			/* Swap it with the bottom part of the bottom segment.  */
			for (i = 0; i < len; i++) {
				tem = argv[bottom + i];
				argv[bottom + i] = argv[middle + i];
				argv[middle + i] = tem;
			}
			/* Exclude the moved top segment from further swapping.  */
			bottom += len;
		}
	}
	/* Update records for the slots the non-options now occupy.  */
	d->first_nonopt += (d->custom_optind - d->last_nonopt);
	d->last_nonopt = d->custom_optind;
}

/* Initialize the internal data when the first call is made.  */
static void custom_getopt_initialize(struct custom_getopt_data *d)
{
	/*
	 * Start processing options with ARGV-element 1 (since ARGV-element 0
	 * is the program name); the sequence of previously skipped non-option
	 * ARGV-elements is empty.
	 */
	d->first_nonopt = d->last_nonopt = d->custom_optind;
	d->nextchar = NULL;
	d->initialized = 1;
}

#define NONOPTION_P (argv[d->custom_optind][0] != '-' || argv[d->custom_optind][1] == '\0')

/* return: zero: continue, nonzero: return given value to user */
static int shuffle_argv(int argc, char *const *argv,const struct option *longopts,
	struct custom_getopt_data *d)
{
	/*
	 * Give FIRST_NONOPT & LAST_NONOPT rational values if CUSTOM_OPTIND has been
	 * moved back by the user (who may also have changed the arguments).
	 */
	if (d->last_nonopt > d->custom_optind)
		d->last_nonopt = d->custom_optind;
	if (d->first_nonopt > d->custom_optind)
		d->first_nonopt = d->custom_optind;
	/*
	 * If we have just processed some options following some
	 * non-options, exchange them so that the options come first.
	 */
	if (d->first_nonopt != d->last_nonopt &&
			d->last_nonopt != d->custom_optind)
		exchange((char **) argv, d);
	else if (d->last_nonopt != d->custom_optind)
		d->first_nonopt = d->custom_optind;
	/*
	 * Skip any additional non-options and extend the range of
	 * non-options previously skipped.
	 */
	while (d->custom_optind < argc && NONOPTION_P)
		d->custom_optind++;
	d->last_nonopt = d->custom_optind;
	/*
	 * The special ARGV-element `--' means premature end of options.  Skip
	 * it like a null option, then exchange with previous non-options as if
	 * it were an option, then skip everything else like a non-option.
	 */
	if (d->custom_optind != argc && !strcmp(argv[d->custom_optind], "--")) {
		d->custom_optind++;
		if (d->first_nonopt != d->last_nonopt
				&& d->last_nonopt != d->custom_optind)
			exchange((char **) argv, d);
		else if (d->first_nonopt == d->last_nonopt)
			d->first_nonopt = d->custom_optind;
		d->last_nonopt = argc;
		d->custom_optind = argc;
	}
	/*
	 * If we have done all the ARGV-elements, stop the scan and back over
	 * any non-options that we skipped and permuted.
	 */
	if (d->custom_optind == argc) {
		/*
		 * Set the next-arg-index to point at the non-options that we
		 * previously skipped, so the caller will digest them.
		 */
		if (d->first_nonopt != d->last_nonopt)
			d->custom_optind = d->first_nonopt;
		return -1;
	}
	/*
	 * If we have come to a non-option and did not permute it, either stop
	 * the scan or describe it to the caller and pass it by.
	 */
	if (NONOPTION_P) {
		d->custom_optarg = argv[d->custom_optind++];
		return 1;
	}
	/*
	 * We have found another option-ARGV-element. Skip the initial
	 * punctuation.
	 */
	d->nextchar = (argv[d->custom_optind] + 1 + (longopts != NULL && argv[d->custom_optind][1] == '-'));
	return 0;
}

/*
 * Check whether the ARGV-element is a long option.
 *
 * If there's a long option "fubar" and the ARGV-element is "-fu", consider
 * that an abbreviation of the long option, just like "--fu", and not "-f" with
 * arg "u".
 *
 * This distinction seems to be the most useful approach.
 *
 */
static int check_long_opt(int argc, char *const *argv, const char *optstring,
		const struct option *longopts, int *longind,
		int print_errors, struct custom_getopt_data *d)
{
	char *nameend;
	const struct option *p;
	const struct option *pfound = NULL;
	int exact = 0;
	int ambig = 0;
	int indfound = -1;
	int option_index;

	for (nameend = d->nextchar; *nameend && *nameend != '='; nameend++)
		/* Do nothing.  */ ;

	/* Test all long options for either exact match or abbreviated matches */
	for (p = longopts, option_index = 0; p->name; p++, option_index++)
		if (!strncmp(p->name, d->nextchar, nameend - d->nextchar)) {
			if ((unsigned int) (nameend - d->nextchar)
					== (unsigned int) strlen(p->name)) {
				/* Exact match found.  */
				pfound = p;
				indfound = option_index;
				exact = 1;
				break;
			} else if (pfound == NULL) {
				/* First nonexact match found.  */
				pfound = p;
				indfound = option_index;
			} else if (pfound->has_arg != p->has_arg
					|| pfound->flag != p->flag
					|| pfound->val != p->val)
				/* Second or later nonexact match found.  */
				ambig = 1;
		}
	if (ambig && !exact) {
		if (print_errors) {
			fprintf(stderr,
				"%s: option `%s' is ambiguous\n",
				argv[0], argv[d->custom_optind]);
		}
		d->nextchar += strlen(d->nextchar);
		d->custom_optind++;
		d->custom_optopt = 0;
		return '?';
	}
	if (pfound) {
		option_index = indfound;
		d->custom_optind++;
		if (*nameend) {
			if (pfound->has_arg != no_argument)
				d->custom_optarg = nameend + 1;
			else {
				if (print_errors) {
					if (argv[d->custom_optind - 1][1] == '-') {
						/* --option */
						fprintf(stderr, "%s: option `--%s' doesn't allow an argument\n",
							argv[0], pfound->name);
					} else {
						/* +option or -option */
						fprintf(stderr, "%s: option `%c%s' doesn't allow an argument\n",
							argv[0], argv[d->custom_optind - 1][0], pfound->name);
					}

				}
				d->nextchar += strlen(d->nextchar);
				d->custom_optopt = pfound->val;
				return '?';
			}
		} else if (pfound->has_arg == required_argument) {
			if (d->custom_optind < argc)
				d->custom_optarg = argv[d->custom_optind++];
			else {
				if (print_errors) {
					fprintf(stderr,
						"%s: option `%s' requires an argument\n",
						argv[0],
						argv[d->custom_optind - 1]);
				}
				d->nextchar += strlen(d->nextchar);
				d->custom_optopt = pfound->val;
				return optstring[0] == ':' ? ':' : '?';
			}
		}
		d->nextchar += strlen(d->nextchar);
		if (longind != NULL)
			*longind = option_index;
		if (pfound->flag) {
			*(pfound->flag) = pfound->val;
			return 0;
		}
		return pfound->val;
	}
	/*
	 * Can't find it as a long option.  If this is not getopt_long_only, or
	 * the option starts with '--' or is not a valid short option, then
	 * it's an error.  Otherwise interpret it as a short option.
	 */
	if (print_errors) {
		if (argv[d->custom_optind][1] == '-') {
			/* --option */
			fprintf(stderr,
				"%s: unrecognized option `--%s'\n",
				argv[0], d->nextchar);
		} else {
			/* +option or -option */
			fprintf(stderr,
				"%s: unrecognized option `%c%s'\n",
				argv[0], argv[d->custom_optind][0],
				d->nextchar);
		}
	}
	d->nextchar = (char *) "";
	d->custom_optind++;
	d->custom_optopt = 0;
	return '?';
}

static int check_short_opt(int argc, char *const *argv, const char *optstring,
		int print_errors, struct custom_getopt_data *d)
{
	char c = *d->nextchar++;
	const char *temp = strchr(optstring, c);

	/* Increment `custom_optind' when we start to process its last character.  */
	if (*d->nextchar == '\0')
		++d->custom_optind;
	if (!temp || c == ':') {
		if (print_errors)
			fprintf(stderr, "%s: invalid option -- %c\n", argv[0], c);

		d->custom_optopt = c;
		return '?';
	}
	if (temp[1] == ':') {
		if (temp[2] == ':') {
			/* This is an option that accepts an argument optionally.  */
			if (*d->nextchar != '\0') {
				d->custom_optarg = d->nextchar;
				d->custom_optind++;
			} else
				d->custom_optarg = NULL;
			d->nextchar = NULL;
		} else {
			/* This is an option that requires an argument.  */
			if (*d->nextchar != '\0') {
				d->custom_optarg = d->nextchar;
				/*
				 * If we end this ARGV-element by taking the
				 * rest as an arg, we must advance to the next
				 * element now.
				 */
				d->custom_optind++;
			} else if (d->custom_optind == argc) {
				if (print_errors) {
					fprintf(stderr,
						"%s: option requires an argument -- %c\n",
						argv[0], c);
				}
				d->custom_optopt = c;
				if (optstring[0] == ':')
					c = ':';
				else
					c = '?';
			} else
				/*
				 * We already incremented `custom_optind' once;
				 * increment it again when taking next ARGV-elt
				 * as argument.
				 */
				d->custom_optarg = argv[d->custom_optind++];
			d->nextchar = NULL;
		}
	}
	return c;
}

/*
 * Scan elements of ARGV for option characters given in OPTSTRING.
 *
 * If an element of ARGV starts with '-', and is not exactly "-" or "--",
 * then it is an option element.  The characters of this element
 * (aside from the initial '-') are option characters.  If `getopt'
 * is called repeatedly, it returns successively each of the option characters
 * from each of the option elements.
 *
 * If `getopt' finds another option character, it returns that character,
 * updating `custom_optind' and `nextchar' so that the next call to `getopt' can
 * resume the scan with the following option character or ARGV-element.
 *
 * If there are no more option characters, `getopt' returns -1.
 * Then `custom_optind' is the index in ARGV of the first ARGV-element
 * that is not an option.  (The ARGV-elements have been permuted
 * so that those that are not options now come last.)
 *
 * OPTSTRING is a string containing the legitimate option characters.
 * If an option character is seen that is not listed in OPTSTRING,
 * return '?' after printing an error message.  If you set `custom_opterr' to
 * zero, the error message is suppressed but we still return '?'.
 *
 * If a char in OPTSTRING is followed by a colon, that means it wants an arg,
 * so the following text in the same ARGV-element, or the text of the following
 * ARGV-element, is returned in `custom_optarg'.  Two colons mean an option that
 * wants an optional arg; if there is text in the current ARGV-element,
 * it is returned in `custom_optarg', otherwise `custom_optarg' is set to zero.
 *
 * If OPTSTRING starts with `-' or `+', it requests different methods of
 * handling the non-option ARGV-elements.
 * See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
 *
 * Long-named options begin with `--' instead of `-'.
 * Their names may be abbreviated as long as the abbreviation is unique
 * or is an exact match for some defined option.  If they have an
 * argument, it follows the option name in the same ARGV-element, separated
 * from the option name by a `=', or else the in next ARGV-element.
 * When `getopt' finds a long-named option, it returns 0 if that option's
 * `flag' field is nonzero, the value of the option's `val' field
 * if the `flag' field is zero.
 *
 * The elements of ARGV aren't really const, because we permute them.
 * But we pretend they're const in the prototype to be compatible
 * with other systems.
 *
 * LONGOPTS is a vector of `struct option' terminated by an
 * element containing a name which is zero.
 *
 * LONGIND returns the index in LONGOPT of the long-named option found.
 * It is only valid when a long-named option has been found by the most
 * recent call.
 *
 * Return the option character from OPTS just read.  Return -1 when there are
 * no more options.  For unrecognized options, or options missing arguments,
 * `custom_optopt' is set to the option letter, and '?' is returned.
 *
 * The OPTS string is a list of characters which are recognized option letters,
 * optionally followed by colons, specifying that that letter takes an
 * argument, to be placed in `custom_optarg'.
 *
 * If a letter in OPTS is followed by two colons, its argument is optional.
 * This behavior is specific to the GNU `getopt'.
 *
 * The argument `--' causes premature termination of argument scanning,
 * explicitly telling `getopt' that there are no more options.  If OPTS begins
 * with `--', then non-option arguments are treated as arguments to the option
 * '\0'.  This behavior is specific to the GNU `getopt'.
 */

static int getopt_internal_r(int argc, char *const *argv, const char *optstring,
		const struct option *longopts, int *longind,
		struct custom_getopt_data *d)
{
	int ret, print_errors = d->custom_opterr;

	if (optstring[0] == ':')
		print_errors = 0;
	if (argc < 1)
		return -1;
	d->custom_optarg = NULL;

	/* 
	 * This is a big difference with GNU getopt, since optind == 0
	 * means initialization while here 1 means first call.
	 */
	if (d->custom_optind == 0 || !d->initialized) {
		if (d->custom_optind == 0)
			d->custom_optind = 1;	/* Don't scan ARGV[0], the program name.  */
		custom_getopt_initialize(d);
	}
	if (d->nextchar == NULL || *d->nextchar == '\0') {
		ret = shuffle_argv(argc, argv, longopts, d);
		if (ret)
			return ret;
	}
	if (longopts && (argv[d->custom_optind][1] == '-' ))
		return check_long_opt(argc, argv, optstring, longopts,
			longind, print_errors, d);
	return check_short_opt(argc, argv, optstring, print_errors, d);
}

static int custom_getopt_internal(int argc, char *const *argv, const char *optstring,
	const struct option *longopts, int *longind)
{
	int result;
	/* Keep a global copy of all internal members of d */
	static struct custom_getopt_data d;

	d.custom_optind = custom_optind;
	d.custom_opterr = custom_opterr;
	result = getopt_internal_r(argc, argv, optstring, longopts,
		longind, &d);
	custom_optind = d.custom_optind;
	custom_optarg = d.custom_optarg;
	custom_optopt = d.custom_optopt;
	return result;
}

static int custom_getopt_long (int argc, char *const *argv, const char *options,
	const struct option *long_options, int *opt_index)
{
	return custom_getopt_internal(argc, argv, options, long_options,
		opt_index);
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see RNAalifold_cmdline_parser_params.check_ambiguity
 * @param override @see RNAalifold_cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               RNAalifold_cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  FIX_UNUSED (default_value);
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_INT:
    if (val) *((int *)field) = strtol (val, &stop_char, 0);
    break;
  case ARG_LONG:
    if (val) *((long *)field) = (long)strtol (val, &stop_char, 0);
    break;
  case ARG_FLOAT:
    if (val) *((float *)field) = (float)strtod (val, &stop_char);
    break;
  case ARG_DOUBLE:
    if (val) *((double *)field) = strtod (val, &stop_char);
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_INT:
  case ARG_LONG:
  case ARG_FLOAT:
  case ARG_DOUBLE:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}

/**
 * @brief store information about a multiple option in a temporary list
 * @param list where to (temporarily) store multiple options
 */
static
int update_multiple_arg_temp(struct generic_list **list,
               unsigned int *prev_given, const char *val,
               const char *possible_values[], const char *default_value,
               RNAalifold_cmdline_parser_arg_type arg_type,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  /* store single arguments */
  char *multi_token;
  const char *multi_next;

  if (arg_type == ARG_NO) {
    (*prev_given)++;
    return 0; /* OK */
  }

  multi_token = get_multiple_arg_token(val);
  multi_next = get_multiple_arg_token_next (val);

  while (1)
    {
      add_node (list);
      if (update_arg((void *)&((*list)->arg), &((*list)->orig), 0,
          prev_given, multi_token, possible_values, default_value, 
          arg_type, 0, 1, 1, 1, long_opt, short_opt, additional_error)) {
        if (multi_token) free(multi_token);
        return 1; /* failure */
      }

      if (multi_next)
        {
          multi_token = get_multiple_arg_token(multi_next);
          multi_next = get_multiple_arg_token_next (multi_next);
        }
      else
        break;
    }

  return 0; /* OK */
}

/**
 * @brief free the passed list (including possible string argument)
 */
static
void free_list(struct generic_list *list, short string_arg)
{
  if (list) {
    struct generic_list *tmp;
    while (list)
      {
        tmp = list;
        if (string_arg && list->arg.string_arg)
          free (list->arg.string_arg);
        if (list->orig)
          free (list->orig);
        list = list->next;
        free (tmp);
      }
  }
}

/**
 * @brief updates a multiple option starting from the passed list
 */
static
void update_multiple_arg(void *field, char ***orig_field,
               unsigned int field_given, unsigned int prev_given, union generic_value *default_value,
               RNAalifold_cmdline_parser_arg_type arg_type,
               struct generic_list *list)
{
  int i;
  struct generic_list *tmp;

  if (prev_given && list) {
    *orig_field = (char **) realloc (*orig_field, (field_given + prev_given) * sizeof (char *));

    switch(arg_type) {
    case ARG_INT:
      *((int **)field) = (int *)realloc (*((int **)field), (field_given + prev_given) * sizeof (int)); break;
    case ARG_LONG:
      *((long **)field) = (long *)realloc (*((long **)field), (field_given + prev_given) * sizeof (long)); break;
    case ARG_FLOAT:
      *((float **)field) = (float *)realloc (*((float **)field), (field_given + prev_given) * sizeof (float)); break;
    case ARG_DOUBLE:
      *((double **)field) = (double *)realloc (*((double **)field), (field_given + prev_given) * sizeof (double)); break;
    case ARG_STRING:
      *((char ***)field) = (char **)realloc (*((char ***)field), (field_given + prev_given) * sizeof (char *)); break;
    default:
      break;
    };
    
    for (i = (prev_given - 1); i >= 0; --i)
      {
        tmp = list;
        
        switch(arg_type) {
        case ARG_INT:
          (*((int **)field))[i + field_given] = tmp->arg.int_arg; break;
        case ARG_LONG:
          (*((long **)field))[i + field_given] = tmp->arg.long_arg; break;
        case ARG_FLOAT:
          (*((float **)field))[i + field_given] = tmp->arg.float_arg; break;
        case ARG_DOUBLE:
          (*((double **)field))[i + field_given] = tmp->arg.double_arg; break;
        case ARG_STRING:
          (*((char ***)field))[i + field_given] = tmp->arg.string_arg; break;
        default:
          break;
        }        
        (*orig_field) [i + field_given] = list->orig;
        list = list->next;
        free (tmp);
      }
  } else { /* set the default value */
    if (default_value && ! field_given) {
      switch(arg_type) {
      case ARG_INT:
        if (! *((int **)field)) {
          *((int **)field) = (int *)malloc (sizeof (int));
          (*((int **)field))[0] = default_value->int_arg; 
        }
        break;
      case ARG_LONG:
        if (! *((long **)field)) {
          *((long **)field) = (long *)malloc (sizeof (long));
          (*((long **)field))[0] = default_value->long_arg;
        }
        break;
      case ARG_FLOAT:
        if (! *((float **)field)) {
          *((float **)field) = (float *)malloc (sizeof (float));
          (*((float **)field))[0] = default_value->float_arg;
        }
        break;
      case ARG_DOUBLE:
        if (! *((double **)field)) {
          *((double **)field) = (double *)malloc (sizeof (double));
          (*((double **)field))[0] = default_value->double_arg;
        }
        break;
      case ARG_STRING:
        if (! *((char ***)field)) {
          *((char ***)field) = (char **)malloc (sizeof (char *));
          (*((char ***)field))[0] = gengetopt_strdup(default_value->string_arg);
        }
        break;
      default: break;
      }
      if (!(*orig_field)) {
        *orig_field = (char **) malloc (sizeof (char *));
        (*orig_field)[0] = 0;
      }
    }
  }
}

int
RNAalifold_cmdline_parser_internal (
  int argc, char **argv, struct RNAalifold_args_info *args_info,
                        struct RNAalifold_cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  struct generic_list * shape_list = NULL;
  int error_occurred = 0;
  struct RNAalifold_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;

  char *optarg;
  int optind;
  int opterr;
  int optopt;
  
  package_name = argv[0];
  
  /* TODO: Why is this here? It is not used anywhere. */
  override = params->override;
  FIX_UNUSED(override);

  initialize = params->initialize;
  check_required = params->check_required;

  /* TODO: Why is this here? It is not used anywhere. */
  check_ambiguity = params->check_ambiguity;
  FIX_UNUSED(check_ambiguity);

  if (initialize)
    RNAalifold_cmdline_parser_init (args_info);

  RNAalifold_cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "detailed-help",	0, NULL, 0 },
        { "full-help",	0, NULL, 0 },
        { "version",	0, NULL, 'V' },
        { "verbose",	0, NULL, 'v' },
        { "quiet",	0, NULL, 'q' },
        { "jobs",	2, NULL, 'j' },
        { "unordered",	0, NULL, 0 },
        { "noconv",	0, NULL, 0 },
        { "color",	0, NULL, 0 },
        { "aln",	0, NULL, 0 },
        { "aln-EPS-cols",	1, NULL, 0 },
        { "aln-stk",	2, NULL, 0 },
        { "layout-type",	1, NULL, 't' },
        { "noPS",	0, NULL, 0 },
        { "noDP",	0, NULL, 0 },
        { "input-format",	1, NULL, 'f' },
        { "continuous-ids",	0, NULL, 'n' },
        { "auto-id",	0, NULL, 0 },
        { "id-prefix",	1, NULL, 0 },
        { "id-delim",	1, NULL, 0 },
        { "id-digits",	1, NULL, 0 },
        { "id-start",	1, NULL, 0 },
        { "filename-delim",	1, NULL, 0 },
        { "maxBPspan",	1, NULL, 0 },
        { "constraint",	2, NULL, 'C' },
        { "batch",	0, NULL, 0 },
        { "enforceConstraint",	0, NULL, 0 },
        { "SS_cons",	0, NULL, 0 },
        { "shape",	1, NULL, 0 },
        { "shapeMethod",	1, NULL, 0 },
        { "partfunc",	2, NULL, 'p' },
        { "MEA",	2, NULL, 0 },
        { "mis",	0, NULL, 0 },
        { "stochBT",	1, NULL, 's' },
        { "stochBT_en",	1, NULL, 0 },
        { "nonRedundant",	0, NULL, 'N' },
        { "pfScale",	1, NULL, 'S' },
        { "circ",	0, NULL, 'c' },
        { "bppmThreshold",	1, NULL, 0 },
        { "gquad",	0, NULL, 'g' },
        { "sci",	0, NULL, 0 },
        { "temp",	1, NULL, 'T' },
        { "noTetra",	0, NULL, '4' },
        { "dangles",	1, NULL, 'd' },
        { "noLP",	0, NULL, 0 },
        { "noGU",	0, NULL, 0 },
        { "noClosingGU",	0, NULL, 0 },
        { "cfactor",	1, NULL, 0 },
        { "nfactor",	1, NULL, 0 },
        { "endgaps",	0, NULL, 'E' },
        { "ribosum_file",	1, NULL, 'R' },
        { "ribosum_scoring",	0, NULL, 'r' },
        { "old",	0, NULL, 0 },
        { "paramFile",	1, NULL, 'P' },
        { "nsp",	1, NULL, 0 },
        { "energyModel",	1, NULL, 'e' },
        { "betaScale",	1, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      custom_optarg = optarg;
      custom_optind = optind;
      custom_opterr = opterr;
      custom_optopt = optopt;

      c = custom_getopt_long (argc, argv, "hVvqj::t:f:nC::p::s:NS:cgT:4d:ER:rP:e:", long_options, &option_index);

      optarg = custom_optarg;
      optind = custom_optind;
      opterr = custom_opterr;
      optopt = custom_optopt;

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          RNAalifold_cmdline_parser_print_help ();
          RNAalifold_cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          RNAalifold_cmdline_parser_print_version ();
          RNAalifold_cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'v':	/* Be verbose.
        
.  */
        
        
          if (update_arg((void *)&(args_info->verbose_flag), 0, &(args_info->verbose_given),
              &(local_args_info.verbose_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "verbose", 'v',
              additional_error))
            goto failure;
        
          break;
        case 'q':	/* Be quiet.
.  */
        
        
          if (update_arg((void *)&(args_info->quiet_flag), 0, &(args_info->quiet_given),
              &(local_args_info.quiet_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "quiet", 'q',
              additional_error))
            goto failure;
        
          break;
        case 'j':	/* Split batch input into jobs and start processing in parallel using multiple threads. A value of 0 indicates to use as many parallel threads as computation cores are available.
.  */
        
        
          if (update_arg( (void *)&(args_info->jobs_arg), 
               &(args_info->jobs_orig), &(args_info->jobs_given),
              &(local_args_info.jobs_given), optarg, 0, "0", ARG_INT,
              check_ambiguity, override, 0, 0,
              "jobs", 'j',
              additional_error))
            goto failure;
        
          break;
        case 't':	/* Choose the layout algorithm. Simple radial layout if 0, or naview if 1
        
.  */
        
        
          if (update_arg( (void *)&(args_info->layout_type_arg), 
               &(args_info->layout_type_orig), &(args_info->layout_type_given),
              &(local_args_info.layout_type_given), optarg, 0, "1", ARG_INT,
              check_ambiguity, override, 0, 0,
              "layout-type", 't',
              additional_error))
            goto failure;
        
          break;
        case 'f':	/* File format of the input multiple sequence alignment (MSA).
.  */
        
        
          if (update_arg( (void *)&(args_info->input_format_arg), 
               &(args_info->input_format_orig), &(args_info->input_format_given),
              &(local_args_info.input_format_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "input-format", 'f',
              additional_error))
            goto failure;
        
          break;
        case 'n':	/* Use continuous alignment ID numbering when no alignment ID can be retrieved from input data.
.  */
        
        
          if (update_arg((void *)&(args_info->continuous_ids_flag), 0, &(args_info->continuous_ids_given),
              &(local_args_info.continuous_ids_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "continuous-ids", 'n',
              additional_error))
            goto failure;
        
          break;
        case 'C':	/* Calculate structures subject to constraints.
        The constraining structure will be read from 'stdin', the alignment has to be given as a file name on the command line.
.  */
        
        
          if (update_arg( (void *)&(args_info->constraint_arg), 
               &(args_info->constraint_orig), &(args_info->constraint_given),
              &(local_args_info.constraint_given), optarg, 0, "", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "constraint", 'C',
              additional_error))
            goto failure;
        
          break;
        case 'p':	/* Calculate the partition function and base pairing probability matrix in addition to the mfe structure. Default is calculation of mfe structure only.
.  */
        
        
          if (update_arg( (void *)&(args_info->partfunc_arg), 
               &(args_info->partfunc_orig), &(args_info->partfunc_given),
              &(local_args_info.partfunc_given), optarg, 0, "1", ARG_INT,
              check_ambiguity, override, 0, 0,
              "partfunc", 'p',
              additional_error))
            goto failure;
        
          break;
        case 's':	/* Stochastic backtrack. Compute a certain number of random structures with a probability dependend on the partition function. See -p option in RNAsubopt.
        
.  */
        
        
          if (update_arg( (void *)&(args_info->stochBT_arg), 
               &(args_info->stochBT_orig), &(args_info->stochBT_given),
              &(local_args_info.stochBT_given), optarg, 0, 0, ARG_INT,
              check_ambiguity, override, 0, 0,
              "stochBT", 's',
              additional_error))
            goto failure;
        
          break;
        case 'N':	/* Enable non-redundant sampling strategy.
        
.  */
        
        
          if (update_arg((void *)&(args_info->nonRedundant_flag), 0, &(args_info->nonRedundant_given),
              &(local_args_info.nonRedundant_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "nonRedundant", 'N',
              additional_error))
            goto failure;
        
          break;
        case 'S':	/* In the calculation of the pf use scale*mfe as an estimate for the ensemble free energy (used to avoid overflows).
.  */
        
        
          if (update_arg( (void *)&(args_info->pfScale_arg), 
               &(args_info->pfScale_orig), &(args_info->pfScale_given),
              &(local_args_info.pfScale_given), optarg, 0, 0, ARG_DOUBLE,
              check_ambiguity, override, 0, 0,
              "pfScale", 'S',
              additional_error))
            goto failure;
        
          break;
        case 'c':	/* Assume a circular (instead of linear) RNA molecule.
        
.  */
        
        
          if (update_arg((void *)&(args_info->circ_flag), 0, &(args_info->circ_given),
              &(local_args_info.circ_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "circ", 'c',
              additional_error))
            goto failure;
        
          break;
        case 'g':	/* Incoorporate G-Quadruplex formation into the structure prediction algorithm.
        
.  */
        
        
          if (update_arg((void *)&(args_info->gquad_flag), 0, &(args_info->gquad_given),
              &(local_args_info.gquad_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "gquad", 'g',
              additional_error))
            goto failure;
        
          break;
        case 'T':	/* Rescale energy parameters to a temperature of temp C. Default is 37C.
        
.  */
        
        
          if (update_arg( (void *)&(args_info->temp_arg), 
               &(args_info->temp_orig), &(args_info->temp_given),
              &(local_args_info.temp_given), optarg, 0, 0, ARG_DOUBLE,
              check_ambiguity, override, 0, 0,
              "temp", 'T',
              additional_error))
            goto failure;
        
          break;
        case '4':	/* Do not include special tabulated stabilizing energies for tri-, tetra- and hexaloop hairpins.
        
.  */
        
        
          if (update_arg((void *)&(args_info->noTetra_flag), 0, &(args_info->noTetra_given),
              &(local_args_info.noTetra_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "noTetra", '4',
              additional_error))
            goto failure;
        
          break;
        case 'd':	/* How to treat \"dangling end\" energies for bases adjacent to helices in free ends and multi-loops
.  */
        
        
          if (update_arg( (void *)&(args_info->dangles_arg), 
               &(args_info->dangles_orig), &(args_info->dangles_given),
              &(local_args_info.dangles_given), optarg, 0, "2", ARG_INT,
              check_ambiguity, override, 0, 0,
              "dangles", 'd',
              additional_error))
            goto failure;
        
          break;
        case 'E':	/* Score pairs with endgaps same as gap-gap pairs.
        
.  */
        
        
          if (update_arg((void *)&(args_info->endgaps_flag), 0, &(args_info->endgaps_given),
              &(local_args_info.endgaps_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "endgaps", 'E',
              additional_error))
            goto failure;
        
          break;
        case 'R':	/* use specified Ribosum Matrix instead of normal energy model. Matrixes to use should be 6x6 matrices, the order of the terms is AU, CG, GC, GU, UA, UG.
        
.  */
        
        
          if (update_arg( (void *)&(args_info->ribosum_file_arg), 
               &(args_info->ribosum_file_orig), &(args_info->ribosum_file_given),
              &(local_args_info.ribosum_file_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "ribosum_file", 'R',
              additional_error))
            goto failure;
        
          break;
        case 'r':	/* use ribosum scoring matrix. The matrix is chosen according to the minimal and maximal pairwise identities of the sequences in the file.
        
.  */
        
        
          if (update_arg((void *)&(args_info->ribosum_scoring_flag), 0, &(args_info->ribosum_scoring_given),
              &(local_args_info.ribosum_scoring_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "ribosum_scoring", 'r',
              additional_error))
            goto failure;
        
          break;
        case 'P':	/* Read energy parameters from paramfile, instead of using the default parameter set.
.  */
        
        
          if (update_arg( (void *)&(args_info->paramFile_arg), 
               &(args_info->paramFile_orig), &(args_info->paramFile_given),
              &(local_args_info.paramFile_given), optarg, 0, 0, ARG_STRING,
              check_ambiguity, override, 0, 0,
              "paramFile", 'P',
              additional_error))
            goto failure;
        
          break;
        case 'e':	/* Rarely used option to fold sequences from the artificial ABCD... alphabet, where A pairs B, C-D etc.  Use the energy parameters for GC (-e 1) or AU (-e 2) pairs.
        
.  */
        
        
          if (update_arg( (void *)&(args_info->energyModel_arg), 
               &(args_info->energyModel_orig), &(args_info->energyModel_given),
              &(local_args_info.energyModel_given), optarg, 0, 0, ARG_INT,
              check_ambiguity, override, 0, 0,
              "energyModel", 'e',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          if (strcmp (long_options[option_index].name, "detailed-help") == 0) {
            RNAalifold_cmdline_parser_print_detailed_help ();
            RNAalifold_cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);
          }

          if (strcmp (long_options[option_index].name, "full-help") == 0) {
            RNAalifold_cmdline_parser_print_full_help ();
            RNAalifold_cmdline_parser_free (&local_args_info);
            exit (EXIT_SUCCESS);
          }

          /* Do not try to keep output in order with input while parallel processing is in place.
.  */
          if (strcmp (long_options[option_index].name, "unordered") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->unordered_flag), 0, &(args_info->unordered_given),
                &(local_args_info.unordered_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "unordered", '-',
                additional_error))
              goto failure;
          
          }
          /* Do not automatically substitute nucleotide \"T\" with \"U\"
          
.  */
          else if (strcmp (long_options[option_index].name, "noconv") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->noconv_flag), 0, &(args_info->noconv_given),
                &(local_args_info.noconv_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "noconv", '-',
                additional_error))
              goto failure;
          
          }
          /* Produce a colored version of the consensus structure plot \"alirna.ps\" (default b&w only)
          
.  */
          else if (strcmp (long_options[option_index].name, "color") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->color_flag), 0, &(args_info->color_given),
                &(local_args_info.color_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "color", '-',
                additional_error))
              goto failure;
          
          }
          /* Produce a colored and structure annotated alignment in PostScript format in the file \"aln.ps\" in the current directory.
          
.  */
          else if (strcmp (long_options[option_index].name, "aln") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->aln_flag), 0, &(args_info->aln_given),
                &(local_args_info.aln_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "aln", '-',
                additional_error))
              goto failure;
          
          }
          /* Number of columns in colored EPS alignment output.
.  */
          else if (strcmp (long_options[option_index].name, "aln-EPS-cols") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->aln_EPS_cols_arg), 
                 &(args_info->aln_EPS_cols_orig), &(args_info->aln_EPS_cols_given),
                &(local_args_info.aln_EPS_cols_given), optarg, 0, "60", ARG_INT,
                check_ambiguity, override, 0, 0,
                "aln-EPS-cols", '-',
                additional_error))
              goto failure;
          
          }
          /* Create a multi-Stockholm formatted output file.
.  */
          else if (strcmp (long_options[option_index].name, "aln-stk") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->aln_stk_arg), 
                 &(args_info->aln_stk_orig), &(args_info->aln_stk_given),
                &(local_args_info.aln_stk_given), optarg, 0, "RNAalifold_results", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "aln-stk", '-',
                additional_error))
              goto failure;
          
          }
          /* Do not produce postscript drawing of the mfe structure.
          
.  */
          else if (strcmp (long_options[option_index].name, "noPS") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->noPS_flag), 0, &(args_info->noPS_given),
                &(local_args_info.noPS_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "noPS", '-',
                additional_error))
              goto failure;
          
          }
          /* Do not produce dot-plot postscript file containing base pair or stack probabilitities.
.  */
          else if (strcmp (long_options[option_index].name, "noDP") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->noDP_flag), 0, &(args_info->noDP_given),
                &(local_args_info.noDP_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "noDP", '-',
                additional_error))
              goto failure;
          
          }
          /* Automatically generate an ID for each alignment.
.  */
          else if (strcmp (long_options[option_index].name, "auto-id") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->auto_id_flag), 0, &(args_info->auto_id_given),
                &(local_args_info.auto_id_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "auto-id", '-',
                additional_error))
              goto failure;
          
          }
          /* Prefix for automatically generated IDs (as used in output file names)
          
.  */
          else if (strcmp (long_options[option_index].name, "id-prefix") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->id_prefix_arg), 
                 &(args_info->id_prefix_orig), &(args_info->id_prefix_given),
                &(local_args_info.id_prefix_given), optarg, 0, "alignment", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "id-prefix", '-',
                additional_error))
              goto failure;
          
          }
          /* Change the delimiter between prefix and increasing number for automatically generated IDs (as used in output file names)
          
.  */
          else if (strcmp (long_options[option_index].name, "id-delim") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->id_delim_arg), 
                 &(args_info->id_delim_orig), &(args_info->id_delim_given),
                &(local_args_info.id_delim_given), optarg, 0, "_", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "id-delim", '-',
                additional_error))
              goto failure;
          
          }
          /* Specify the number of digits of the counter in automatically generated alignment IDs.
.  */
          else if (strcmp (long_options[option_index].name, "id-digits") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->id_digits_arg), 
                 &(args_info->id_digits_orig), &(args_info->id_digits_given),
                &(local_args_info.id_digits_given), optarg, 0, "4", ARG_INT,
                check_ambiguity, override, 0, 0,
                "id-digits", '-',
                additional_error))
              goto failure;
          
          }
          /* Specify the first number in automatically generated alignment IDs.
.  */
          else if (strcmp (long_options[option_index].name, "id-start") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->id_start_arg), 
                 &(args_info->id_start_orig), &(args_info->id_start_given),
                &(local_args_info.id_start_given), optarg, 0, "1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "id-start", '-',
                additional_error))
              goto failure;
          
          }
          /* Change the delimiting character that is used for sanitized filenames
          
.  */
          else if (strcmp (long_options[option_index].name, "filename-delim") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->filename_delim_arg), 
                 &(args_info->filename_delim_orig), &(args_info->filename_delim_given),
                &(local_args_info.filename_delim_given), optarg, 0, "ID-delimiter", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "filename-delim", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the maximum base pair span
          
.  */
          else if (strcmp (long_options[option_index].name, "maxBPspan") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->maxBPspan_arg), 
                 &(args_info->maxBPspan_orig), &(args_info->maxBPspan_given),
                &(local_args_info.maxBPspan_given), optarg, 0, "-1", ARG_INT,
                check_ambiguity, override, 0, 0,
                "maxBPspan", '-',
                additional_error))
              goto failure;
          
          }
          /* Use constraints for all alignment records.
.  */
          else if (strcmp (long_options[option_index].name, "batch") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->batch_flag), 0, &(args_info->batch_given),
                &(local_args_info.batch_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "batch", '-',
                additional_error))
              goto failure;
          
          }
          /* Enforce base pairs given by round brackets ( ) in structure constraint
          
.  */
          else if (strcmp (long_options[option_index].name, "enforceConstraint") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->enforceConstraint_flag), 0, &(args_info->enforceConstraint_given),
                &(local_args_info.enforceConstraint_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "enforceConstraint", '-',
                additional_error))
              goto failure;
          
          }
          /* Use consensus structures from Stockholm file (#=GF SS_cons) as constraint
.  */
          else if (strcmp (long_options[option_index].name, "SS_cons") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->SS_cons_flag), 0, &(args_info->SS_cons_given),
                &(local_args_info.SS_cons_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "SS_cons", '-',
                additional_error))
              goto failure;
          
          }
          /* Use SHAPE reactivity data to guide structure predictions
.  */
          else if (strcmp (long_options[option_index].name, "shape") == 0)
          {
          
            if (update_multiple_arg_temp(&shape_list, 
                &(local_args_info.shape_given), optarg, 0, 0, ARG_STRING,
                "shape", '-',
                additional_error))
              goto failure;
          
          }
          /* Specify the method how to convert SHAPE reactivity data to pseudo energy contributions
.  */
          else if (strcmp (long_options[option_index].name, "shapeMethod") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->shapeMethod_arg), 
                 &(args_info->shapeMethod_orig), &(args_info->shapeMethod_given),
                &(local_args_info.shapeMethod_given), optarg, 0, "D", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "shapeMethod", '-',
                additional_error))
              goto failure;
          
          }
          /* Calculate an MEA (maximum expected accuracy) structure, where the expected accuracy is computed from the pair probabilities: each base pair (i,j) gets a score 2*gamma*p_ij and the score of an unpaired base is given by the probability of not forming a pair.
.  */
          else if (strcmp (long_options[option_index].name, "MEA") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->MEA_arg), 
                 &(args_info->MEA_orig), &(args_info->MEA_given),
                &(local_args_info.MEA_given), optarg, 0, "1.", ARG_FLOAT,
                check_ambiguity, override, 0, 0,
                "MEA", '-',
                additional_error))
              goto failure;
          
          }
          /* Output \"most informative sequence\" instead of simple consensus: For each column of the alignment output the set of nucleotides with frequency greater than average in IUPAC notation.
          
.  */
          else if (strcmp (long_options[option_index].name, "mis") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->mis_flag), 0, &(args_info->mis_given),
                &(local_args_info.mis_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "mis", '-',
                additional_error))
              goto failure;
          
          }
          /* same as \"-s\" but also print out the energies and probabilities of the backtraced structures.
          
.  */
          else if (strcmp (long_options[option_index].name, "stochBT_en") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->stochBT_en_arg), 
                 &(args_info->stochBT_en_orig), &(args_info->stochBT_en_given),
                &(local_args_info.stochBT_en_given), optarg, 0, 0, ARG_INT,
                check_ambiguity, override, 0, 0,
                "stochBT_en", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the threshold for base pair probabilities included in the postscript output
.  */
          else if (strcmp (long_options[option_index].name, "bppmThreshold") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->bppmThreshold_arg), 
                 &(args_info->bppmThreshold_orig), &(args_info->bppmThreshold_given),
                &(local_args_info.bppmThreshold_given), optarg, 0, "1e-6", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "bppmThreshold", '-',
                additional_error))
              goto failure;
          
          }
          /* Compute the structure conservation index (SCI) for the MFE consensus structure of the alignment
          
.  */
          else if (strcmp (long_options[option_index].name, "sci") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->sci_flag), 0, &(args_info->sci_given),
                &(local_args_info.sci_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "sci", '-',
                additional_error))
              goto failure;
          
          }
          /* Produce structures without lonely pairs (helices of length 1).
.  */
          else if (strcmp (long_options[option_index].name, "noLP") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->noLP_flag), 0, &(args_info->noLP_given),
                &(local_args_info.noLP_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "noLP", '-',
                additional_error))
              goto failure;
          
          }
          /* Do not allow GU pairs
          
.  */
          else if (strcmp (long_options[option_index].name, "noGU") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->noGU_flag), 0, &(args_info->noGU_given),
                &(local_args_info.noGU_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "noGU", '-',
                additional_error))
              goto failure;
          
          }
          /* Do not allow GU pairs at the end of helices
          
.  */
          else if (strcmp (long_options[option_index].name, "noClosingGU") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->noClosingGU_flag), 0, &(args_info->noClosingGU_given),
                &(local_args_info.noClosingGU_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "noClosingGU", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the weight of the covariance term in the energy function
          
.  */
          else if (strcmp (long_options[option_index].name, "cfactor") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->cfactor_arg), 
                 &(args_info->cfactor_orig), &(args_info->cfactor_given),
                &(local_args_info.cfactor_given), optarg, 0, "1.0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "cfactor", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the penalty for non-compatible sequences in the covariance term of the energy function
          
.  */
          else if (strcmp (long_options[option_index].name, "nfactor") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->nfactor_arg), 
                 &(args_info->nfactor_orig), &(args_info->nfactor_given),
                &(local_args_info.nfactor_given), optarg, 0, "1.0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "nfactor", '-',
                additional_error))
              goto failure;
          
          }
          /* use old energy evaluation, treating gaps as characters.
          
.  */
          else if (strcmp (long_options[option_index].name, "old") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->old_flag), 0, &(args_info->old_given),
                &(local_args_info.old_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "old", '-',
                additional_error))
              goto failure;
          
          }
          /* Allow other pairs in addition to the usual AU,GC,and GU pairs.
.  */
          else if (strcmp (long_options[option_index].name, "nsp") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->nsp_arg), 
                 &(args_info->nsp_orig), &(args_info->nsp_given),
                &(local_args_info.nsp_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "nsp", '-',
                additional_error))
              goto failure;
          
          }
          /* Set the scaling of the Boltzmann factors
.  */
          else if (strcmp (long_options[option_index].name, "betaScale") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->betaScale_arg), 
                 &(args_info->betaScale_orig), &(args_info->betaScale_given),
                &(local_args_info.betaScale_given), optarg, 0, "1.", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "betaScale", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", RNAALIFOLD_CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */


  update_multiple_arg((void *)&(args_info->shape_arg),
    &(args_info->shape_orig), args_info->shape_given,
    local_args_info.shape_given, 0,
    ARG_STRING, shape_list);

  args_info->shape_given += local_args_info.shape_given;
  local_args_info.shape_given = 0;
  
  if (check_required)
    {
      error_occurred += RNAalifold_cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  RNAalifold_cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */


      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind++]) ;
    }

  return 0;

failure:
  free_list (shape_list, 1 );
  
  RNAalifold_cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
/* vim: set ft=c noet ts=8 sts=8 sw=8 tw=80 nojs spell : */
